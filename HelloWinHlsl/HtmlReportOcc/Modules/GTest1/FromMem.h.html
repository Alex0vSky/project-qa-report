<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>FromMem.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Tool/Shader/Loader/SourceCode/FromMem.h - loader shader from shader source code placed in memory
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Tool::Shader::Loader::SourceCode {
template&lt;class TSPE,class T&gt; class FromMem; // primary template

template&lt;class T&gt; class FromMem&lt;DxVer::v9,T&gt; {
	using TInnerDxVer = DxVer::v9;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit FromMem(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	// preference vertex shader model version is 3_0
	CPtr&lt; IDirect3DVertexShader9 &gt; 
	Vs(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt;ID3DXBuffer&gt; *ppcVBlob = nullptr
	) {
		return Vs30( strShadeSourceCode, strEntryPointName, ppcVBlob );
	}
	// preference pixel shader model version is 3_0
	CPtr&lt; IDirect3DPixelShader9 &gt; 
	Ps(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
	) {
		return Ps30( strShadeSourceCode, strEntryPointName );
	}

	CPtr&lt; IDirect3DVertexShader9 &gt; 
	Vs30(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt;ID3DXBuffer&gt; *ppcVBlob = nullptr
	) {
		HRESULT hr;
		CPtr&lt;ID3DXBuffer&gt; pcBlob; 
		CPtr&lt; IDirect3DVertexShader9 &gt; pcVS;
		hr = ::D3DXCompileShader( 
				strShadeSourceCode.c_str( ), (UINT)strShadeSourceCode.length( ), NULL, NULL
				, strEntryPointName.c_str( ), "vs_3_0", 0
				, pcBlob.ReleaseAndGetAddressOf( ), nullptr, nullptr 
			);
		if ( FAILED( hr ) )
			return { };
		hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateVertexShader( 
				static_cast&lt;DWORD *&gt;( pcBlob -&gt;GetBufferPointer( ) )
				, pcVS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		if ( ppcVBlob )
			*ppcVBlob = pcBlob;
		return pcVS;
	}

	CPtr&lt; IDirect3DPixelShader9 &gt; 
	Ps30(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
	) {
		HRESULT hr;
		CPtr&lt;ID3DXBuffer&gt; pcBlob; 
		CPtr&lt; IDirect3DPixelShader9 &gt; pcPS;
		CPtr&lt; ID3DXBuffer &gt; pcErrorMsgs;
		hr = ::D3DXCompileShader( 
				strShadeSourceCode.c_str( )
				, (UINT)strShadeSourceCode.length( ), NULL, NULL
				, strEntryPointName.c_str( ), "ps_3_0", 0
				, pcBlob.ReleaseAndGetAddressOf( ), pcErrorMsgs.ReleaseAndGetAddressOf( ), nullptr 
			);
		if ( FAILED( hr ) ) {
			char *szErrorMsgs = static_cast&lt;char *&gt;( pcErrorMsgs -&gt;GetBufferPointer( ) );
			UNREFERENCED_PARAMETER( szErrorMsgs );
			return { };
		}
		hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreatePixelShader( 
				static_cast&lt;DWORD *&gt;( pcBlob -&gt;GetBufferPointer( ) )
				, pcPS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		return pcPS;
	}
};

template&lt;class T&gt; class FromMem&lt;DxVer::v10,T&gt; {
	using TInnerDxVer = DxVer::v10;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit FromMem(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	// preference vertex shader model version is 4_0
	CPtr&lt; ID3D10VertexShader &gt; 
	Vs(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt;ID3D10Blob&gt; *ppcVBlob = nullptr
	) {
		return Vs40( strShadeSourceCode, strEntryPointName, ppcVBlob );
	}
	// preference pixel shader model version is 4_0
	CPtr&lt; ID3D10PixelShader &gt; 
	Ps(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
	) {
		return Ps40( strShadeSourceCode, strEntryPointName );
	}

	// Load the vertex shader of the "vs_4_0" model, from string.
	CPtr&lt;ID3D10VertexShader&gt; 
	Vs40(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt;ID3D10Blob&gt; *ppcVBlob = nullptr
	) {
		HRESULT hr;
		CPtr&lt;ID3D10Blob&gt; pcBlob;
		hr = ::D3D10CompileShader(
				strShadeSourceCode.c_str( ), strShadeSourceCode.length( )
				, NULL, NULL, NULL, strEntryPointName.c_str( ), "vs_4_0", 0
				, pcBlob.ReleaseAndGetAddressOf( ), NULL
			);
		if ( FAILED( hr ) )
			return { };
		CPtr&lt;ID3D10VertexShader&gt; pcVS;
		hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateVertexShader( 
				pcBlob -&gt;GetBufferPointer( )
				, pcBlob -&gt;GetBufferSize( )
				, pcVS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		if ( ppcVBlob )
			*ppcVBlob = pcBlob;
		return pcVS;
	}

	// Load the pixel shader of the vs_4_0 model, from string.
	CPtr&lt;ID3D10PixelShader&gt; 
	Ps40(
			const std::string &amp;strShadeSourceCode
			, const std::string &amp;strEntryPointName = "main"
		)
	{
		HRESULT hr;
		CPtr&lt;ID3D10Blob&gt; pcBlob;
		hr = ::D3D10CompileShader(
				strShadeSourceCode.c_str( ), strShadeSourceCode.length( )
				, NULL, NULL, NULL, strEntryPointName.c_str( ), "ps_4_0", 0, pcBlob.ReleaseAndGetAddressOf( ), NULL
			);
		if ( FAILED( hr ) )
			return { };
		CPtr&lt;ID3D10PixelShader&gt; pcPS;
		hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreatePixelShader( 
				pcBlob -&gt;GetBufferPointer( )
				, pcBlob -&gt;GetBufferSize( )
				, pcPS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		return pcPS;
	}

};

template&lt;class T&gt; class FromMem&lt;DxVer::v11,T&gt; {
	using TInnerDxVer = DxVer::v11;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit FromMem(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	// preference vertex shader model version is 4_0
	CPtr&lt; ID3D11VertexShader &gt; 
	Vs(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt; ID3DBlob &gt; *ppcVBlob = nullptr
	) {
		return Vs40( strShadeSourceCode, strEntryPointName, ppcVBlob );
	}
	// preference pixel shader model version is 4_0
	CPtr&lt; ID3D11PixelShader &gt; 
	Ps(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
	) {
		return Ps40( strShadeSourceCode, strEntryPointName );
	}

	// Load the vertex shader of the "vs_4_0" model, from string.
	CPtr&lt;ID3D11VertexShader&gt; 
	Vs40(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt; ID3DBlob &gt; *ppcVBlob = nullptr
	) {
		HRESULT hr;
		CPtr&lt; ID3DBlob &gt; pcBlob;
		hr = ::D3DCompile( 
				strShadeSourceCode.c_str( ), strShadeSourceCode.length( )
				, nullptr, nullptr, nullptr, strEntryPointName.c_str( ), "vs_4_0", 0, 0
				, pcBlob.ReleaseAndGetAddressOf( ), NULL
			);
		if ( FAILED( hr ) )
			return { };
		CPtr&lt;ID3D11VertexShader&gt; pcVS;
		hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateVertexShader( 
				pcBlob -&gt;GetBufferPointer( )
				, pcBlob -&gt;GetBufferSize( )
				, nullptr
				, pcVS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		if ( ppcVBlob )
			*ppcVBlob = pcBlob;
		return pcVS;
	}

	// Load the pixel shader of the vs_4_0 model, from string.
	CPtr&lt; ID3D11PixelShader &gt; 
	Ps40(
			const std::string &amp;strShadeSourceCode
			, const std::string &amp;strEntryPointName = "main"
		)
	{
		HRESULT hr;
		CPtr&lt; ID3DBlob &gt; pcBlob;
		hr = ::D3DCompile( 
				strShadeSourceCode.c_str( ), strShadeSourceCode.length( )
				, nullptr, nullptr, nullptr, strEntryPointName.c_str( ), "ps_4_0", 0, 0
				, pcBlob.ReleaseAndGetAddressOf( ), NULL
			);
		if ( FAILED( hr ) )
			return { };
		CPtr&lt; ID3D11PixelShader &gt; pcPS;
		hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreatePixelShader( 
				pcBlob -&gt;GetBufferPointer( )
				, pcBlob -&gt;GetBufferSize( )
				, nullptr
				, pcPS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		return pcPS;
	}

};

template&lt;class T&gt; class FromMem&lt;DxVer::v12,T&gt; {
	using TInnerDxVer = DxVer::v12;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
	UINT m_compileFlags;
public:
	explicit FromMem(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{
		m_compileFlags = 0;</span>
		// Enable better shader debugging with the graphics debugging tools.
#ifdef _DEBUG
<span style = "background-color:#fdd">		m_compileFlags |= D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;</span>
#endif
<span style = "background-color:#fdd">	}</span>

	// preference vertex shader model version is 5_0
	CPtr&lt; ID3DBlob &gt; 
	Vs(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt; ID3DBlob &gt; *ppcVBlob = nullptr
	) {
		return Vs50( strShadeSourceCode, strEntryPointName, ppcVBlob );
	}
	// preference pixel shader model version is 5_0
	CPtr&lt; ID3DBlob &gt; 
	Ps(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
	) {
		return Ps50( strShadeSourceCode, strEntryPointName );
	}

	// Load the vertex shader of the "vs_5_0" model, from string.
	CPtr&lt;ID3DBlob&gt; 
	Vs50(
		const std::string &amp;strShadeSourceCode
		, const std::string &amp;strEntryPointName = "main"
		, CPtr&lt; ID3DBlob &gt; *ppcVBlob = nullptr
	) {
		HRESULT hr;
		CPtr&lt; ID3DBlob &gt; pcBlob;
		hr = ::D3DCompile( 
				strShadeSourceCode.c_str( ), strShadeSourceCode.length( )
				, nullptr, nullptr, nullptr, strEntryPointName.c_str( ), "vs_5_0", m_compileFlags, 0
				, pcBlob.ReleaseAndGetAddressOf( ), nullptr
			);
		if ( FAILED( hr ) )
			return { };
		if ( ppcVBlob )
			*ppcVBlob = pcBlob;
		return pcBlob;
	}

	// Load the pixel shader of the vs_5_0 model, from string.
	CPtr&lt; ID3DBlob &gt; 
	Ps50(
			const std::string &amp;strShadeSourceCode
			, const std::string &amp;strEntryPointName = "main"
		)
	{
		HRESULT hr;
		CPtr&lt; ID3DBlob &gt; pcBlob;
		hr = ::D3DCompile( 
				strShadeSourceCode.c_str( ), strShadeSourceCode.length( )
				, nullptr, nullptr, nullptr, strEntryPointName.c_str( ), "ps_5_0", m_compileFlags, 0
				, pcBlob.ReleaseAndGetAddressOf( ), NULL
			);
		if ( FAILED( hr ) )
			return { };
		return pcBlob;
	}

};
} // namespace prj_3d::HelloWinHlsl::Dx::Tool::Shader::Loader::SourceCode</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>