<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Ordinary.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// DrawAux/Fps/Ordinary.h - second try "Direct2D/DXGI Interoperation Sample".
// It's interesting that everything works without "if (SUCCEEDED(CoInitialize(NULL)))".
// You can no longer use "D3DX10CreateFont". https://stackoverflow.com/questions/42333236/cannot-open-source-file-d3dx10-h
// @insp https://github.com/microsoft/Windows-classic-samples/blob/main/Samples/Win7Samples/multimedia/DirectWrite/HelloWorld/SimpleText.cpp
// @insp https://docs.microsoft.com/en-us/samples/microsoft/windows-classic-samples/direct2ddxgi/
// @insp https://github.com/microsoft/Windows-classic-samples/blob/main/Samples/Win7Samples/multimedia/Direct2D/DXGISample/DxgiSample.cpp
// @insp https://github.com/Microsoft/DirectXTK/wiki/ComPtr
// @insp https://www.unknowncheats.me/forum/d3d-tutorials-and-source/126704-drawing-function-directx-9-a.html
// TODO: rename Fps/Ordinary to Fps/ToWindowSufrace or Fps/ToTexture or Fps/ToImage
#pragma once
namespace prj_3d::HelloWinHlsl::DrawAux::Fps { 
template&lt;class T&gt; class Ordinary; // primary template

namespace detail_ {
// Drawing config
struct BaseDrawCfg {
<span style = "background-color:#fdd">	static INT getFontSize() {
		return 28;
	}
	static auto getFontFamily() {
		return std::wstring( L"Arial" );
	}
	static RECT getRect() {
		return RECT{ 0, 0, 200, 50 };
	}
	static D2D1::ColorF getColor() {
		return D2D1::ColorF( D2D1::ColorF::White );
	}</span>
};
template&lt;class T&gt; struct DrawCfg; // primary template
template&lt;&gt; struct DrawCfg&lt;DxVer::v9&gt; : public BaseDrawCfg {

<span style = "background-color:#fdd">	static D3DCOLOR getColor() {
		auto color = BaseDrawCfg::getColor( );
		return D3DCOLOR_XRGB( BYTE(color.r*255.f), BYTE(color.g*255.f), BYTE(color.b*255.f) );
	}</span>
};
template&lt;&gt; struct DrawCfg&lt;DxVer::v10&gt; : public BaseDrawCfg {
<span style = "background-color:#fdd">	static FLOAT getFontSize() {
		return (FLOAT)BaseDrawCfg::getFontSize( );
	}
	static D2D_RECT_F getRect() {
		auto r = BaseDrawCfg::getRect( );
		return D2D1::RectF( (FLOAT)r.left, (FLOAT)r.top, (FLOAT)r.right, (FLOAT)r.bottom );
	}</span>
};

template&lt;&gt; struct DrawCfg&lt;DxVer::v11&gt; : public BaseDrawCfg {
<span style = "background-color:#fdd">	static FLOAT getFontSize() {
		return (FLOAT)BaseDrawCfg::getFontSize( );
	}
	static D2D_RECT_F getRect() {
		auto r = BaseDrawCfg::getRect( );
		return D2D1::RectF( (FLOAT)r.left, (FLOAT)r.top, (FLOAT)r.right, (FLOAT)r.bottom );
	}</span>
};

template&lt;&gt; struct DrawCfg&lt;DxVer::v12&gt; : public BaseDrawCfg {
	// Only left-top corner possible right now
<span style = "background-color:#fdd">	static DirectX::SimpleMath::Vector2 getRect() {
		auto r = BaseDrawCfg::getRect( );
		return DirectX::SimpleMath::Vector2( </span>
				(float)r.left
				, (float)r.top
			);
<span style = "background-color:#fdd">	}</span>
};

// Let's get the average FPS value on a certain segment so that the number does not jump.
// @insp bgfx.
class FrameTime {
	static constexpr float kFloatMin = 1.175494e-38f, kFloatMax = 3.402823e+38f;
	static constexpr uint32_t kNumSamples = 100;
	int32_t m_offset;
	float m_values[kNumSamples];
<span style = "background-color:#fdd">	template&lt;typename Ty&gt; inline constexpr Ty min_(const Ty&amp; _a, const Ty&amp; _b) {
		return _a &lt; _b ? _a : _b;
	}</span>

<span style = "background-color:#fdd">	template&lt;typename Ty&gt; inline constexpr Ty max_(const Ty&amp; _a, const Ty&amp; _b) {
		return _a &gt; _b ? _a : _b;
	}</span>
public:
	float m_min, m_max, m_avg;
	FrameTime() // = default;
<span style = "background-color:#fdd">		: m_offset(0), m_values{ }, m_min(0), m_max(0), m_avg(0)
	{}
	void pushSample(float value) {
		m_values[m_offset] = value;
		m_offset = (m_offset + 1) % kNumSamples;
		float fMin = kFloatMax;
		float fMax = -kFloatMax;
		float avg = 0.0f;
		for (uint32_t ii = 0; ii &lt; kNumSamples; ++ii) {
			const float val = m_values[ii];
			fMin = this-&gt;min_( fMin, val );
			fMax = this-&gt;max_( fMax, val );
			avg += val;
		}
		m_min = fMin;
		m_max = fMax;
		m_avg = avg / kNumSamples;
	}
	int64_t getHPFrequency() {</span>
		LARGE_INTEGER li;
<span style = "background-color:#fdd">		QueryPerformanceFrequency( &amp;li );
		return li.QuadPart;
    }
	int64_t getHPCounter() {</span>
		LARGE_INTEGER li;
<span style = "background-color:#fdd">		QueryPerformanceCounter( &amp;li );
		return li.QuadPart;
	}</span>
};

} // namespace detail_ _

template&lt;&gt; class Ordinary&lt;DxVer::v9&gt; {
	using TInnerDxVer = DxVer::v9;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;

    int64_t m_llFrameTimeLast, m_llCpuTimerFreq;
	detail_::FrameTime stFrameTime;

	CPtr&lt; ID3DXFont &gt; m_pcFont;
public:
    typedef uptr&lt; Ordinary &gt; uptr_t;
    explicit Ordinary(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx)
<span style = "background-color:#fdd">        : m_stDxCtx( stDxCtx )
	{
		Sys::Hr hr = ::D3DXCreateFontW( </span>
				m_stDxCtx -&gt;m_pcD3dDevice.Get( )
				, detail_::DrawCfg&lt;TInnerDxVer&gt;::getFontSize( ), 0
				, FW_NORMAL, 1, 0 
				, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH
				, detail_::DrawCfg&lt;TInnerDxVer&gt;::getFontFamily( ).c_str( )
				, m_pcFont.ReleaseAndGetAddressOf( )
			);
<span style = "background-color:#fdd">        m_llFrameTimeLast = stFrameTime.getHPCounter( );
        m_llCpuTimerFreq = stFrameTime.getHPFrequency( );
	}
	void renderOnTarget() {
		int64_t llNow = stFrameTime.getHPCounter( );</span>
        //!&lt; CPU time between two `bgfx::frame` calls.
<span style = "background-color:#fdd">		int64_t llCpuTimeFrame = llNow - m_llFrameTimeLast;
		m_llFrameTimeLast = llNow;
    	const double toMsCpu = 1000.0 / m_llCpuTimerFreq;
    	const double frameMs = llCpuTimeFrame * toMsCpu;
    	stFrameTime.pushSample( float(frameMs) );
        float fFps = 1000.0f / stFrameTime.m_avg;</span>

<span style = "background-color:#fdd">        std::wstringstream stream;
        stream &lt;&lt; L"FPS " &lt;&lt; (int)fFps;</span>

<span style = "background-color:#fdd">		auto rect = detail_::DrawCfg&lt;TInnerDxVer&gt;::getRect( );</span>
		//HRESULT hr = 
<span style = "background-color:#fdd">			m_pcFont -&gt;DrawTextW( </span>
				NULL, stream.str( ).c_str( ), -1
				, &amp;rect, DT_LEFT|DT_NOCLIP, detail_::DrawCfg&lt;TInnerDxVer&gt;::getColor( ) 
			);
<span style = "background-color:#fdd">		__nop( );
	}</span>
};

template&lt;&gt; class Ordinary&lt;DxVer::v10&gt; {
	using TInnerDxVer = DxVer::v10;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
    CPtr&lt;ID2D1RenderTarget&gt; m_pcBackBufferRT;
    CPtr&lt;ID2D1SolidColorBrush&gt; m_pcBackBufferTextBrush;
    CPtr&lt;IDWriteTextFormat&gt; m_pcTextFormat;

	int64_t m_llFrameTimeLast, m_llCpuTimerFreq;
	detail_::FrameTime stFrameTime;
public:
    typedef uptr&lt; Ordinary &gt; uptr_t;
    explicit Ordinary(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx)
<span style = "background-color:#fdd">        : m_stDxCtx( stDxCtx )
    {
        CPtr&lt; IDWriteFactory &gt; pcDWriteFactory;
        CPtr&lt; ID2D1Factory &gt; pcD2DFactory;
        Sys::Hr hr;</span>

        // It's CreateDeviceIndependentResources()
<span style = "background-color:#fdd">        hr = ::D2D1CreateFactory( </span>
				D2D1_FACTORY_TYPE_SINGLE_THREADED 
				, pcD2DFactory.ReleaseAndGetAddressOf( ) 
			);

<span style = "background-color:#fdd">        hr = ::DWriteCreateFactory(</span>
				DWRITE_FACTORY_TYPE_SHARED
				, __uuidof( IDWriteFactory )
				, reinterpret_cast&lt; IUnknown** &gt;( pcDWriteFactory.ReleaseAndGetAddressOf( ) )
			);

<span style = "background-color:#fdd">        hr = pcDWriteFactory -&gt;CreateTextFormat(</span>
            detail_::DrawCfg&lt;TInnerDxVer&gt;::getFontFamily( ).c_str( ),
            NULL,                       // Font collection (NULL sets it to use the system font collection).
            DWRITE_FONT_WEIGHT_REGULAR,
            DWRITE_FONT_STYLE_NORMAL,
            DWRITE_FONT_STRETCH_NORMAL,
            detail_::DrawCfg&lt;TInnerDxVer&gt;::getFontSize( ),
            L"en-us",
            m_pcTextFormat.ReleaseAndGetAddressOf( )
        );
        // Center align (horizontally) the text.
<span style = "background-color:#fdd">        hr = m_pcTextFormat-&gt;SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
        hr = m_pcTextFormat-&gt;SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);</span>

<span style = "background-color:#fdd">        CPtr&lt; ID3D10Texture2D &gt; pcOffscreenTexture;</span>
        // Allocate a offscreen D3D surface for D2D to render our 2D content into
        D3D10_TEXTURE2D_DESC texDesc;
<span style = "background-color:#fdd">        texDesc.ArraySize = 1;
        texDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
        texDesc.CPUAccessFlags = 0;
        texDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
        texDesc.Height = 512;
        texDesc.Width = 512;
        texDesc.MipLevels = 1;
        texDesc.MiscFlags = 0;
        texDesc.SampleDesc.Count = 1;
        texDesc.SampleDesc.Quality = 0;
        texDesc.Usage = D3D10_USAGE_DEFAULT;
        hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateTexture2D( </span>
				&amp;texDesc
				, NULL
				, pcOffscreenTexture.ReleaseAndGetAddressOf( ) 
			);
<span style = "background-color:#fdd">        CPtr&lt; IDXGISurface &gt; pcDxgiSurface;
		hr = pcOffscreenTexture.As( std::addressof( pcDxgiSurface ) );</span>

		// Create the DXGI Surface Render Target.
<span style = "background-color:#fdd">        D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(</span>
            D2D1_RENDER_TARGET_TYPE_DEFAULT,
            D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
            96,
            96
        );
<span style = "background-color:#fdd">        CPtr&lt; ID2D1RenderTarget &gt; pcRenderTarget;
        hr = pcD2DFactory -&gt;CreateDxgiSurfaceRenderTarget(</span>
				pcDxgiSurface.Get( )
				, &amp;props
				, pcRenderTarget.ReleaseAndGetAddressOf( )
			);

        // Create a red brush for text drawn into the back buffer
<span style = "background-color:#fdd">        hr = pcRenderTarget -&gt;CreateSolidColorBrush(</span>
            detail_::DrawCfg&lt;TInnerDxVer&gt;::getColor( )
            , m_pcBackBufferTextBrush.ReleaseAndGetAddressOf()
        );
<span style = "background-color:#fdd">        CPtr&lt; IDXGISurface &gt; pcBackBuffer;</span>
        // Get a surface in the swap chain
<span style = "background-color:#fdd">        hr = m_stDxCtx -&gt;m_pcDxgiSwapChain-&gt;GetBuffer(</span>
				0
				, IID_PPV_ARGS( pcBackBuffer.ReleaseAndGetAddressOf( ) )
			);

        // It is assumed that the window will change size.
<span style = "background-color:#fdd">        DXGI_SWAP_CHAIN_DESC stDxgiSwapChainDesc = {};
        m_stDxCtx -&gt;m_pcDxgiSwapChain-&gt;GetDesc(&amp;stDxgiSwapChainDesc); // or IDXGISwapChain1::GetHwnd method (dxgi1_2.h)</span>
        FLOAT dpiX, dpiY;
<span style = "background-color:#fdd">        dpiX = dpiY = (FLOAT)::GetDpiForWindow(stDxgiSwapChainDesc.OutputWindow); //pcD2DFactory -&gt;GetDesktopDpi( &amp;dpiX, &amp;dpiY ); // @depr
        D2D1_RENDER_TARGET_PROPERTIES props2 = D2D1::RenderTargetProperties(</span>
            D2D1_RENDER_TARGET_TYPE_DEFAULT,
            D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
            dpiX,
            dpiY
        );

        // Create a D2D render target which can draw into the surface in the swap chain
<span style = "background-color:#fdd">        hr = pcD2DFactory -&gt;CreateDxgiSurfaceRenderTarget(</span>
				pcBackBuffer.Get( )
				, &amp;props2
				// I prefer "ReleaseAndGetAddressOf" instead of 
				// the "ComPtr&lt;TInnerDxVer&gt;::operator&amp;" operator, although 
				// the operator returns "TInnerDxVer**", it releases it 
				// and resets it to zero.
				, m_pcBackBufferRT.ReleaseAndGetAddressOf( )
			);

<span style = "background-color:#fdd">        m_llFrameTimeLast = stFrameTime.getHPCounter( );</span>
        //!&lt; CPU timer frequency. Timestamps-per-second
<span style = "background-color:#fdd">        m_llCpuTimerFreq = stFrameTime.getHPFrequency( );
    }
    void renderOnTarget() {
		int64_t llNow = stFrameTime.getHPCounter( );</span>
        //!&lt; CPU time between two `bgfx::frame` calls.
<span style = "background-color:#fdd">		int64_t llCpuTimeFrame = llNow - m_llFrameTimeLast;
		m_llFrameTimeLast = llNow;
    	const double toMsCpu = 1000.0 / m_llCpuTimerFreq;
    	const double frameMs = llCpuTimeFrame * toMsCpu;
    	stFrameTime.pushSample( float(frameMs) );
        float fFps = 1000.0f / stFrameTime.m_avg;</span>

<span style = "background-color:#fdd">        std::wstringstream stream;
        stream &lt;&lt; L"FPS " &lt;&lt; (int)fFps;</span>

<span style = "background-color:#fdd">        Sys::Hr hr;
        m_pcBackBufferRT -&gt;BeginDraw( );
        m_pcBackBufferRT -&gt;SetTransform( D2D1::Matrix3x2F::Identity( ) );</span>
        // Text format object will center the text in layout
<span style = "background-color:#fdd">        m_pcBackBufferRT -&gt;DrawTextW(</span>
                stream.str( ).c_str( ), (UINT32)stream.str( ).length( ),
                m_pcTextFormat.Get( ),
                detail_::DrawCfg&lt;TInnerDxVer&gt;::getRect( ),
                m_pcBackBufferTextBrush.Get( )
            );
<span style = "background-color:#fdd">        hr = m_pcBackBufferRT-&gt;EndDraw( );
    }</span>
};

// TODO: dont repeat yourself, common code with DxVer::v10
template&lt;&gt; class Ordinary&lt;DxVer::v11&gt; {
	using TInnerDxVer = DxVer::v11;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
    CPtr&lt;ID2D1RenderTarget&gt; m_pcBackBufferRT;
    CPtr&lt;ID2D1SolidColorBrush&gt; m_pcBackBufferTextBrush;
    CPtr&lt;IDWriteTextFormat&gt; m_pcTextFormat;

	int64_t m_llFrameTimeLast, m_llCpuTimerFreq;
	detail_::FrameTime stFrameTime;
public:
    typedef uptr&lt; Ordinary &gt; uptr_t;
    explicit Ordinary(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx)
<span style = "background-color:#fdd">        : m_stDxCtx( stDxCtx )
    {
        CPtr&lt; IDWriteFactory &gt; pcDWriteFactory;
        CPtr&lt; ID2D1Factory &gt; pcD2DFactory;
        Sys::Hr hr;</span>

        // It's CreateDeviceIndependentResources()
<span style = "background-color:#fdd">        hr = D2D1CreateFactory(</span>
				D2D1_FACTORY_TYPE_SINGLE_THREADED
				, pcD2DFactory.ReleaseAndGetAddressOf( )
			);

<span style = "background-color:#fdd">        hr = DWriteCreateFactory(</span>
				DWRITE_FACTORY_TYPE_SHARED
				, __uuidof( IDWriteFactory )
				, reinterpret_cast&lt; IUnknown** &gt;( pcDWriteFactory.ReleaseAndGetAddressOf( ) )
			);

<span style = "background-color:#fdd">        hr = pcDWriteFactory -&gt;CreateTextFormat(</span>
            detail_::DrawCfg&lt;TInnerDxVer&gt;::getFontFamily( ).c_str( ),
            NULL,                       // Font collection (NULL sets it to use the system font collection).
            DWRITE_FONT_WEIGHT_REGULAR,
            DWRITE_FONT_STYLE_NORMAL,
            DWRITE_FONT_STRETCH_NORMAL,
            detail_::DrawCfg&lt;TInnerDxVer&gt;::getFontSize( ),
            L"en-us",
            m_pcTextFormat.ReleaseAndGetAddressOf( )
        );
        // Center align (horizontally) the text.
<span style = "background-color:#fdd">        hr = m_pcTextFormat-&gt;SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
        hr = m_pcTextFormat-&gt;SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);</span>

<span style = "background-color:#fdd">        CPtr&lt; ID3D11Texture2D &gt; pcOffscreenTexture;</span>
        // Allocate a offscreen D3D surface for D2D to render our 2D content into
        D3D11_TEXTURE2D_DESC texDesc;
<span style = "background-color:#fdd">        texDesc.ArraySize = 1;
        texDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
        texDesc.CPUAccessFlags = 0;
        texDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
        texDesc.Height = 512;
        texDesc.Width = 512;
        texDesc.MipLevels = 1;
        texDesc.MiscFlags = 0;
        texDesc.SampleDesc.Count = 1;
        texDesc.SampleDesc.Quality = 0;
        texDesc.Usage = D3D11_USAGE_DEFAULT;
        hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateTexture2D( </span>
				&amp;texDesc
				, NULL
				, pcOffscreenTexture.ReleaseAndGetAddressOf( ) 
			);
<span style = "background-color:#fdd">		CPtr&lt; IDXGISurface &gt; pcDxgiSurface;
		hr = pcOffscreenTexture.As( std::addressof( pcDxgiSurface ) );</span>

        // Create the DXGI Surface Render Target.
<span style = "background-color:#fdd">        D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(</span>
            D2D1_RENDER_TARGET_TYPE_DEFAULT,
            D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
            96,
            96
        );
<span style = "background-color:#fdd">		CPtr&lt; ID2D1RenderTarget &gt; pcRenderTarget;
        hr = pcD2DFactory -&gt;CreateDxgiSurfaceRenderTarget(</span>
				pcDxgiSurface.Get( )
				, &amp;props
				, pcRenderTarget.ReleaseAndGetAddressOf( )
			);

        // Create a red brush for text drawn into the back buffer
<span style = "background-color:#fdd">        hr = pcRenderTarget -&gt;CreateSolidColorBrush(</span>
            detail_::DrawCfg&lt;TInnerDxVer&gt;::getColor( )
            , m_pcBackBufferTextBrush.ReleaseAndGetAddressOf()
        );
<span style = "background-color:#fdd">		CPtr&lt; IDXGISurface &gt; pcBackBuffer;</span>
        // Get a surface in the swap chain
<span style = "background-color:#fdd">        hr = m_stDxCtx -&gt;m_pcDxgiSwapChain-&gt;GetBuffer(</span>
				0
				, IID_PPV_ARGS( pcBackBuffer.ReleaseAndGetAddressOf( ) )
			);

        // It is assumed that the window will change size.
<span style = "background-color:#fdd">        DXGI_SWAP_CHAIN_DESC stDxgiSwapChainDesc = {};
        m_stDxCtx -&gt;m_pcDxgiSwapChain-&gt;GetDesc(&amp;stDxgiSwapChainDesc); // or IDXGISwapChain1::GetHwnd method (dxgi1_2.h)</span>
        FLOAT dpiX, dpiY;
<span style = "background-color:#fdd">        dpiX = dpiY = (FLOAT)::GetDpiForWindow(stDxgiSwapChainDesc.OutputWindow); //pcD2DFactory -&gt;GetDesktopDpi( &amp;dpiX, &amp;dpiY ); // @depr
        D2D1_RENDER_TARGET_PROPERTIES props2 = D2D1::RenderTargetProperties(</span>
            D2D1_RENDER_TARGET_TYPE_DEFAULT,
            D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
            dpiX,
            dpiY
        );

        // Create a D2D render target which can draw into the surface in the swap chain
<span style = "background-color:#fdd">        hr = pcD2DFactory -&gt;CreateDxgiSurfaceRenderTarget(</span>
				pcBackBuffer.Get( )
				, &amp;props2
				// I prefer "ReleaseAndGetAddressOf" instead of 
				// the "ComPtr&lt;TInnerDxVer&gt;::operator&amp;" operator, although 
				// the operator returns "TInnerDxVer**", it releases it 
				// and resets it to zero.
				, m_pcBackBufferRT.ReleaseAndGetAddressOf( )
			);
        // TODO: try to prevent this operator from being used in my code.

<span style = "background-color:#fdd">        m_llFrameTimeLast = stFrameTime.getHPCounter( );</span>
        //!&lt; CPU timer frequency. Timestamps-per-second
<span style = "background-color:#fdd">        m_llCpuTimerFreq = stFrameTime.getHPFrequency( );</span>

<span style = "background-color:#fdd">    }
    void renderOnTarget() {
		int64_t llNow = stFrameTime.getHPCounter( );</span>
        //!&lt; CPU time between two `bgfx::frame` calls.
<span style = "background-color:#fdd">		int64_t llCpuTimeFrame = llNow - m_llFrameTimeLast;
		m_llFrameTimeLast = llNow;
    	const double toMsCpu = 1000.0 / m_llCpuTimerFreq;
    	const double frameMs = llCpuTimeFrame * toMsCpu;
    	stFrameTime.pushSample( float(frameMs) );
        float fFps = 1000.0f / stFrameTime.m_avg;</span>

<span style = "background-color:#fdd">        std::wstringstream stream;
        stream &lt;&lt; L"FPS " &lt;&lt; (int)fFps;</span>

<span style = "background-color:#fdd">        Sys::Hr hr;
        m_pcBackBufferRT -&gt;BeginDraw( );
        m_pcBackBufferRT -&gt;SetTransform( D2D1::Matrix3x2F::Identity( ) );</span>
        // Text format object will center the text in layout
<span style = "background-color:#fdd">        m_pcBackBufferRT -&gt;DrawTextW(</span>
                stream.str( ).c_str( ), (UINT32)stream.str( ).length( ),
                m_pcTextFormat.Get( ),
                detail_::DrawCfg&lt;TInnerDxVer&gt;::getRect( ),
                m_pcBackBufferTextBrush.Get( )
            );
<span style = "background-color:#fdd">        hr = m_pcBackBufferRT-&gt;EndDraw( );
    }</span>
};

template&lt;&gt; class Ordinary&lt;DxVer::v12&gt; {
	using TInnerDxVer = DxVer::v12;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;

	int64_t m_llFrameTimeLast, m_llCpuTimerFreq;
	detail_::FrameTime stFrameTime;

	uptr&lt; DirectX::DescriptorHeap &gt; m_resourceDescriptors;
	uptr&lt; DirectX::SpriteFont &gt; m_font;
	enum Descriptors {
		MyFont,
		Count
	};
	uptr&lt; DirectX::SpriteBatch &gt; m_spriteBatch;
	DirectX::SimpleMath::Vector2 m_fontPos;

	CPtr&lt; ID3D12GraphicsCommandList &gt; m_pc_CommandList;

public:
    typedef uptr&lt; Ordinary &gt; uptr_t;
    explicit Ordinary(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx)
<span style = "background-color:#fdd">        : m_stDxCtx( stDxCtx )
    {</span>
		using namespace DirectX;
<span style = "background-color:#fdd">		auto device = m_stDxCtx -&gt;m_pcD3dDevice12.Get( );
		m_resourceDescriptors = std::make_unique&lt;DescriptorHeap&gt;(</span>
				device
				, Descriptors::Count
			);
<span style = "background-color:#fdd">		ResourceUploadBatch resourceUpload( device );</span>

<span style = "background-color:#fdd">		resourceUpload.Begin( );</span>

<span style = "background-color:#fdd">		const auto &amp;arrayFont = DxtkFont::CompiledToBinary::getArial28( );</span>
		typedef std::remove_cv_t&lt; std::remove_reference_t&lt; decltype( arrayFont ) &gt; &gt; return_t;
		static_assert( std::is_array_v&lt; return_t &gt;, "expect only array" );
		static_assert( std::rank_v&lt; return_t &gt; == 1, "expect only one dimension array" );
		static_assert( std::extent_v&lt; return_t &gt; &gt; 0, "expect only bounded array" );
<span style = "background-color:#fdd">		m_font = std::make_unique&lt;SpriteFont&gt;(</span>
				device
				, resourceUpload
				, arrayFont, sizeof( arrayFont )
				, m_resourceDescriptors-&gt;GetCpuHandle( Descriptors::MyFont )
				, m_resourceDescriptors-&gt;GetGpuHandle( Descriptors::MyFont )
			);

<span style = "background-color:#fdd">		RenderTargetState rtState(</span>
				//m_deviceResources -&gt;GetBackBufferFormat( )
				//, m_deviceResources -&gt;GetDepthBufferFormat( )
				DXGI_FORMAT_R8G8B8A8_UNORM
				, DXGI_FORMAT_R8G8B8A8_UNORM
			);

<span style = "background-color:#fdd">		SpriteBatchPipelineStateDescription pd( rtState );
		m_spriteBatch = std::make_unique&lt;SpriteBatch&gt;( device, resourceUpload, pd );</span>

<span style = "background-color:#fdd">		m_fontPos = detail_::DrawCfg&lt;TInnerDxVer&gt;::getRect( );</span>

<span style = "background-color:#fdd">		auto uploadResourcesFinished = resourceUpload.End(</span>
				m_stDxCtx -&gt;m_pcCommandQueue.Get( )
			);

<span style = "background-color:#fdd">		uploadResourcesFinished.wait( );
        m_llFrameTimeLast = stFrameTime.getHPCounter( );
        m_llCpuTimerFreq = stFrameTime.getHPFrequency( );
    }</span>

<span style = "background-color:#fdd">    void renderOnTarget() {
		int64_t llNow = stFrameTime.getHPCounter( );</span>
        //!&lt; CPU time between two `bgfx::frame` calls.
<span style = "background-color:#fdd">		int64_t llCpuTimeFrame = llNow - m_llFrameTimeLast;
		m_llFrameTimeLast = llNow;
    	const double toMsCpu = 1000.0 / m_llCpuTimerFreq;
    	const double frameMs = llCpuTimeFrame * toMsCpu;
    	stFrameTime.pushSample( float(frameMs) );
        float fFps = 1000.0f / stFrameTime.m_avg;</span>

<span style = "background-color:#fdd">        std::wstringstream stream;
        stream &lt;&lt; L"FPS " &lt;&lt; (int)fFps;</span>

<span style = "background-color:#fdd">		Sys::Hr hr;</span>
		using namespace DirectX;

<span style = "background-color:#fdd">		ID3D12DescriptorHeap* heaps[] = { m_resourceDescriptors -&gt;Heap( ) };
		m_pc_CommandList -&gt;SetDescriptorHeaps(</span>
				static_cast&lt; UINT &gt;( std::size( heaps ) )
				, heaps
			);

<span style = "background-color:#fdd">		m_spriteBatch -&gt;Begin( m_pc_CommandList.Get( ) );</span>

<span style = "background-color:#fdd">		m_font -&gt;DrawString(</span>
				m_spriteBatch.get( )
				, stream.str( ).c_str( )
				, m_fontPos
				, Colors::White
				, 0.f
			);

<span style = "background-color:#fdd">		m_spriteBatch -&gt;End( );
	}</span>

<span style = "background-color:#fdd">	void setDx12Viewport(const D3D12_VIEWPORT &amp;stViewport) {
		m_spriteBatch -&gt;SetViewport( stViewport );
	}
	void setDx12CommandList(const CPtr&lt; ID3D12GraphicsCommandList &gt; &amp;pcCommandList) {
		m_pc_CommandList = pcCommandList;
	}</span>

};
} // namespace prj_3d::HelloWinHlsl::DrawAux::Fps</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>