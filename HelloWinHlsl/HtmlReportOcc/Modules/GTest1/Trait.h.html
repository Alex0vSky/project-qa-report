<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Trait.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Tpl/Trait.h - something like class traits
#pragma once
namespace prj_3d::HelloWinHlsl::Tpl {
struct Trait { 

// For struct initialization
// @insp stackoverflow.com/questions/35298989/using-c-aggregate-initialization-in-stdmake-shared
template&lt;class T&gt;
struct aggregate_adapter : public T {
	template&lt;class... Args&gt;
<span style = "background-color:#fdd">	aggregate_adapter(Args&amp;&amp;... args) : T{ std::forward&lt;Args&gt;(args)... } {}</span>
};
// For struct initialization in make_unique when empty parrent
template&lt;class T&gt;
struct aggregate_adapter_empty_parent : public T {
	template&lt;class... Args&gt;
<span style = "background-color:#fdd">	aggregate_adapter_empty_parent(Args&amp;&amp;... args) : T{ { }, std::forward&lt;Args&gt;(args)... } {}</span>
};

// make unique_ptr from tuple, aggregate_adapter allow make unique_ptr from struct
// @insp stackoverflow.com/questions/74809079/how-to-make-from-tuple-on-the-heap
template&lt;typename obj, typename tup&gt;
static 
auto make_unique_struct_from_tuple(tup&amp;&amp; t) {
    return std::apply(
        [] (auto&amp;&amp; ... args) {
            return std::make_unique&lt; Trait::aggregate_adapter&lt; obj &gt; &gt;
                (std::forward&lt;decltype(args)&gt;(args)...);
        },
        std::forward&lt;tup&gt;(t)
    );
};
template&lt;typename obj, typename tup&gt;
static 
<span style = "background-color:#fdd">auto make_unique_class_from_tuple(tup&amp;&amp; t) {
    return std::apply(
        [] (auto&amp;&amp; ... args) {
            return std::make_unique&lt; obj &gt;</span>
                (std::forward&lt;decltype(args)&gt;(args)...);
<span style = "background-color:#fdd">        },</span>
        std::forward&lt;tup&gt;(t)
    );
<span style = "background-color:#fdd">};</span>

// For empty std deleter
struct nop { template &lt;typename T&gt; void operator() (T const &amp;) const noexcept {} };

// For "if constexpr ... else static_assert()"
template&lt;class&gt; inline static constexpr bool always_false_v = false;

// @insp stackoverflow.com/questions/17254425/getting-the-size-in-bytes-of-a-vector
template&lt;class T&gt; static size_t vectorsizeof(const typename std::vector&lt; T &gt;&amp; vec) { return sizeof( T ) * vec.size( ); }

};
} // namespace prj_3d::HelloWinHlsl::Tpl</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>