<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>IndexBuf.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Tool/IndexBuf.h - Index Buffer creator
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Tool {
template&lt;class T&gt; class IndexBuf; // primary template

template&lt;&gt; class IndexBuf&lt;DxVer::v9&gt; {
	using TInnerDxVer = DxVer::v9;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit IndexBuf(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	struct indexBuf_t {
		const CPtr&lt; IDirect3DIndexBuffer9 &gt; m_pcBuffer;
		const D3DFORMAT m_enuFormat;
	};

	// Supported formats: D3DFORMAT::D3DFMT_INDEX16
	template&lt;class TVE&gt;
	auto createInitialized(const std::vector&lt; TVE &gt; &amp;veMem) {
		D3DFORMAT enuFormat = D3DFORMAT::D3DFMT_UNKNOWN;
		if ( false ) ;
		else {
			if ( 2 == sizeof( TVE ) ) {
				if ( std::is_unsigned_v&lt; TVE &gt; )
					enuFormat = D3DFORMAT::D3DFMT_INDEX16;
			}
		}
		if ( D3DFORMAT::D3DFMT_UNKNOWN == enuFormat )
			return uptr&lt; indexBuf_t &gt;{ }; // nullptr;

		CPtr&lt; IDirect3DIndexBuffer9 &gt; cpIndexBuf;
		size_t si = veMem.size( ) * sizeof( TVE );
		DWORD dwUsage = 0;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateIndexBuffer( 
				si
                , dwUsage, enuFormat
                , D3DPOOL_DEFAULT, cpIndexBuf.ReleaseAndGetAddressOf( ), nullptr
			);
		if ( FAILED( hr ) )
			return uptr&lt; indexBuf_t &gt;{ }; // nullptr;
		void *pVertices;
		hr = cpIndexBuf -&gt;Lock( 0, si, &amp;pVertices, 0 );
		if ( FAILED( hr ) )
			return uptr&lt; indexBuf_t &gt;{ }; // nullptr;
		memcpy( pVertices, &amp;veMem[ 0 ], si );
		cpIndexBuf -&gt;Unlock();

		indexBuf_t stBuf{ 
				cpIndexBuf 
				, enuFormat
			};
		return std::make_unique&lt; indexBuf_t &gt;( stBuf );
	}
};

template&lt;&gt; class IndexBuf&lt;DxVer::v10&gt; {
	using TInnerDxVer = DxVer::v10;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit IndexBuf(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	struct indexBuf_t {
		const CPtr&lt; ID3D10Buffer &gt; m_pcBuffer;
		const DXGI_FORMAT m_enuDxgiFormat;
	};	

	// Supported formats: DXGI_FORMAT_R16_UINT and DXGI_FORMAT_R16_SINT
	// using D3D10_BIND_INDEX_BUFFER flag
	template&lt;class TVE&gt;
	auto createInitialized(const std::vector&lt; TVE &gt; &amp;veMemNdcLH) {
		DXGI_FORMAT enuDxgiFormat = DXGI_FORMAT::DXGI_FORMAT_UNKNOWN;
		if ( false ) ;
		else {
			if ( 2 == sizeof( TVE ) ) {
				if ( std::is_unsigned_v&lt; TVE &gt; )
					enuDxgiFormat = DXGI_FORMAT::DXGI_FORMAT_R16_UINT;
				else 
					enuDxgiFormat = DXGI_FORMAT::DXGI_FORMAT_R16_SINT;
			}
		}
		if ( DXGI_FORMAT::DXGI_FORMAT_UNKNOWN == enuDxgiFormat )
			return uptr&lt; indexBuf_t &gt;{ }; // nullptr;
		D3D10_SUBRESOURCE_DATA stInitData = { &amp;veMemNdcLH[0] };
		D3D10_BUFFER_DESC stBufferDesc = { };
		stBufferDesc.ByteWidth = sizeof( TVE ) * veMemNdcLH.size( );
		stBufferDesc.Usage = D3D10_USAGE_DEFAULT;
		stBufferDesc.BindFlags = D3D10_BIND_INDEX_BUFFER;
		CPtr&lt; ID3D10Buffer &gt; cpIndexBuf;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateBuffer( &amp;stBufferDesc, &amp;stInitData, cpIndexBuf.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return uptr&lt; indexBuf_t &gt;{ }; // nullptr;
		indexBuf_t stBuf{ 
				cpIndexBuf 
				, enuDxgiFormat
			};
		return std::make_unique&lt; indexBuf_t &gt;( stBuf );
	}
};
} // namespace prj_3d::HelloWinHlsl::Dx::Tool</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>