<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Waiter.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Spec/D12/Waiter.h - wait frame ready
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Spec::D12 {
class Waiter {
	static const UINT FrameCount = 2;
	const CPtr&lt; ID3D12Fence &gt; m_pcFence;
	const HANDLE m_hFenceEvent;
	const CPtr&lt; ID3D12CommandQueue &gt; m_pcCommandQueue;
	const CPtr&lt; IDXGISwapChain3 &gt; m_pcDxgiSwapChain;
	std::array&lt; UINT64, FrameCount &gt; m_aruFenceValues;
	UINT m_uFrameIndex;

 public:
	Waiter( 
		CPtr&lt; ID3D12Fence &gt; pcFence
		, HANDLE hFenceEvent
		, CPtr&lt; ID3D12CommandQueue &gt; pcCommandQueue
		, CPtr&lt; IDXGISwapChain3 &gt; pcDxgiSwapChain
		, const std::array&lt; UINT64, FrameCount &gt; &amp;aruFenceValues
		, UINT frameIndex
	)
<span style = "background-color:#fdd">		: m_pcFence( pcFence )
		, m_hFenceEvent( hFenceEvent )
		, m_pcCommandQueue( pcCommandQueue )
		, m_pcDxgiSwapChain( pcDxgiSwapChain )
		, m_aruFenceValues{ aruFenceValues }
		, m_uFrameIndex( frameIndex )
	{}
	void set_frameIndex(UINT frameIndex) {
		m_uFrameIndex = frameIndex;
	}
	UINT get_frameIndex() const {
		return m_uFrameIndex;
	}</span>

	// @insp HelloFrameBuffering\D3D12HelloFrameBuffering.cpp
	// Prepare to render the next frame.
<span style = "background-color:#fdd">	void MoveToNextFrame() {
		Sys::Hr hr;</span>
		// Schedule a Signal command in the queue.
<span style = "background-color:#fdd">		const UINT64 currentFenceValue = m_aruFenceValues[ m_uFrameIndex ];
		hr = m_pcCommandQueue -&gt;Signal( m_pcFence.Get( ), currentFenceValue );</span>

		// Update the frame index.
<span style = "background-color:#fdd">		m_uFrameIndex = m_pcDxgiSwapChain -&gt;GetCurrentBackBufferIndex( );</span>

		// If the next frame is not ready to be rendered yet, wait until it is ready.
<span style = "background-color:#fdd">		if ( m_pcFence -&gt;GetCompletedValue( ) &lt; m_aruFenceValues[ m_uFrameIndex ] ) {
			hr =  m_pcFence -&gt;SetEventOnCompletion( m_aruFenceValues[ m_uFrameIndex ], m_hFenceEvent );
			const BOOL bNotAlertable = FALSE;
			::WaitForSingleObjectEx( m_hFenceEvent, INFINITE, bNotAlertable );</span>
		}

		// Set the fence value for the next frame.
<span style = "background-color:#fdd">		m_aruFenceValues[ m_uFrameIndex ] = currentFenceValue + 1;
	}</span>
	void MoveToNextFrame_signal() {
		Sys::Hr hr;
		// Schedule a Signal command in the queue.
		const UINT64 currentFenceValue = m_aruFenceValues[ m_uFrameIndex ];
		hr = m_pcCommandQueue -&gt;Signal( m_pcFence.Get( ), currentFenceValue );
	}
	void MoveToNextFrame_wait() {
		Sys::Hr hr;
		// Update the frame index.
		m_uFrameIndex = m_pcDxgiSwapChain -&gt;GetCurrentBackBufferIndex( );

		// If the next frame is not ready to be rendered yet, wait until it is ready.
		if ( m_pcFence -&gt;GetCompletedValue( ) &lt; m_aruFenceValues[ m_uFrameIndex ] ) {
			hr =  m_pcFence -&gt;SetEventOnCompletion( m_aruFenceValues[ m_uFrameIndex ], m_hFenceEvent );
			const BOOL bNotAlertable = FALSE;
			::WaitForSingleObjectEx( m_hFenceEvent, INFINITE, bNotAlertable );
		}

		// Set the fence value for the next frame.
		++m_aruFenceValues[ m_uFrameIndex ];
	}
	// Wait for pending GPU work to complete.
<span style = "background-color:#fdd">	void waitForGpu() {
		Sys::Hr hr;</span>
		// After init increment
<span style = "background-color:#fdd">		m_aruFenceValues[ m_uFrameIndex ]++;</span>
		// Schedule a Signal command in the queue.
<span style = "background-color:#fdd">		hr = m_pcCommandQueue -&gt;Signal( m_pcFence.Get( ), m_aruFenceValues[ m_uFrameIndex ] );</span>

	    // Wait until the fence has been processed.
<span style = "background-color:#fdd">		hr = m_pcFence -&gt;SetEventOnCompletion( m_aruFenceValues[ m_uFrameIndex ], m_hFenceEvent );
		const BOOL bNotAlertable = FALSE;
		::WaitForSingleObjectEx( m_hFenceEvent, INFINITE, bNotAlertable );</span>

		// Increment the fence value for the current frame.
<span style = "background-color:#fdd">		m_aruFenceValues[ m_uFrameIndex ]++;
	}</span>
	// For resizer
<span style = "background-color:#fdd">	void afterResetRenderTarget(UINT n) {
		m_aruFenceValues[ n ] = m_aruFenceValues[ m_uFrameIndex ];
	}</span>
};
} // namespace prj_3d::HelloWinHlsl::Dx::Spec::D12</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>