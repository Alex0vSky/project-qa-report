<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>CtxDx.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Ctx/CtxDx.h - structure of DirectX3D context
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Ctx {

template&lt;class T&gt; struct CtxDx; // primary template

namespace detail_ {

template&lt;class T&gt; 
struct CommonDxCtx {
	// const all of them
	typedef sptr&lt; const CtxDx&lt; T &gt; &gt; sptrc_t;
	typedef const sptrc_t &amp;cref_ptr_t;
	// make shared_ptr, work with single argument too
	// @insp stackoverflow.com/questions/35298989/using-c-aggregate-initialization-in-stdmake-shared
<span style = "background-color:#fdd">	template&lt;typename... Args&gt; static auto z_make_shared(Args&amp;&amp;... args) {
		return std::make_shared&lt; CtxDx&lt; T &gt; &gt; ( </span>
				CtxDx&lt; T &gt;{ 
					// parent struct aggregate initialization
					{ }
					// real arguments
					, std::forward&lt;Args&gt;(args)... 
				}
			);
<span style = "background-color:#fdd">	}</span>
};
} // namespace detail_

template&lt;&gt; struct CtxDx&lt;DxVer::v9&gt; : public detail_::CommonDxCtx&lt;DxVer::v9&gt; { 
    const CPtr&lt; IDirect3DDevice9 &gt; m_pcD3dDevice;
};
template&lt;&gt; struct CtxDx&lt;DxVer::v10&gt; : public detail_::CommonDxCtx&lt;DxVer::v10&gt; { 
	const CPtr&lt; IDXGISwapChain &gt; m_pcDxgiSwapChain;
    const CPtr&lt; ID3D10RenderTargetView &gt; m_pcD3dRenderTargetView;
    const CPtr&lt; ID3D10Device &gt; m_pcD3dDevice;
};
template&lt;&gt; struct CtxDx&lt;DxVer::v11&gt; : public detail_::CommonDxCtx&lt;DxVer::v11&gt; { 
	const CPtr&lt; IDXGISwapChain &gt; m_pcDxgiSwapChain;
    const CPtr&lt; ID3D11RenderTargetView &gt; m_pcD3dRenderTargetView;
    const CPtr&lt; ID3D11Device &gt; m_pcD3dDevice;
    const CPtr&lt; ID3D11DeviceContext &gt; m_pcDeviceContext;
};
template&lt;&gt; struct CtxDx&lt;DxVer::v12&gt; : public detail_::CommonDxCtx&lt;DxVer::v12&gt; {
    static const UINT FrameCount = 2;
    const CPtr&lt; ID3D12Device &gt; m_pcD3dDevice12;
	const CPtr&lt; IDXGISwapChain3 &gt; m_pcDxgiSwapChain;
	const std::array&lt; CPtr&lt; ID3D12CommandAllocator &gt;, FrameCount &gt; m_arpcCommandAllocators;
	const CPtr&lt; ID3D12DescriptorHeap &gt; m_rtvHeap;
	const UINT m_rtvDescriptorSize;
	const CPtr&lt; ID3D12CommandQueue &gt; m_pcCommandQueue;
	const D3D12_GRAPHICS_PIPELINE_STATE_DESC m_psoDesc;
	const CPtr&lt; ID3D12RootSignature &gt; m_initialRootSignature;
	struct detail_ {
		const CPtr&lt; ID3D12Fence &gt; m_pcFence;
		const HANDLE m_hFenceEvent;
		const std::array&lt; UINT64, FrameCount &gt; m_aruFenceValues;
		const UINT m_uFrameIndex;
		const CD3DX12_VIEWPORT m_viewport;
		const CD3DX12_RECT m_scissorRect;
		// TODO: how to safe release under const? Need for SwapChain::ResizeBuffers()
		const std::array&lt; CPtr&lt; ID3D12Resource &gt;, FrameCount &gt; m_renderTargets;
		bool m_bTearingSupport;
	} detail_;
};
} // namespace prj_3d::HelloWinHlsl::Dx::Ctx</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>