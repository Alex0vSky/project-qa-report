<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>WindowResizer.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Spec/D12/WindowResizer.h - make windows resize 
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Spec::D12 {
class WindowResizer : public Sys::Wnd::AWndProcHolder {
	using AWndProcHolder::AWndProcHolder;

	Ty::StDxCtx_ptr&lt; DxVer::v12 &gt; m_psstDxCtx;
	std::mutex *m_pMutex = nullptr;
	Dx::Spec::D12::Waiter *m_pWaiter = nullptr;
	Dx::Spec::D12::Resizer *m_pResizer = nullptr;
	bool m_bWindowedMode = true;
	bool m_bFullscreenMode = false;
	RECT m_stWindowRect = { };
	UINT m_uWindowStyle = 0;
	HMENU m_hMenu = nullptr;
	bool m_bIsToggleFullscreenWindow = false;

	typedef std::mutex mutex_t;
	typedef std::lock_guard&lt; mutex_t &gt; lock_t;

<span style = "background-color:#fdd">	void onWindowSizeChanged(UINT width, UINT height) override {
		if ( !m_psstDxCtx ) 
			return;
		uptr&lt; lock_t &gt; scoped;
		if ( m_pMutex ) {
			if ( !m_bIsToggleFullscreenWindow ) {
				scoped = std::make_unique&lt; lock_t &gt;( *m_pMutex );</span>
			}
		}

<span style = "background-color:#fdd">		LONG lWidth = static_cast&lt; LONG &gt;( width )
			, lHeight = static_cast&lt; LONG &gt;( height );
		float fWidth = static_cast&lt; float &gt;( width )
			, fHeight = static_cast&lt; float &gt;( height );</span>

<span style = "background-color:#fdd">		char buff[64] = {};
		sprintf_s( buff, "OnWindowSizeChanged. w: %u, h: %u\n"</span>
				, width, height
			);
<span style = "background-color:#fdd">		::OutputDebugStringA( buff );</span>

<span style = "background-color:#fdd">		Sys::Hr hr;
		m_pWaiter -&gt;waitForGpu( );</span>

		// Release resources that are tied to the swap chain and update fence values.
<span style = "background-color:#fdd">		for (UINT n = 0; n &lt; m_psstDxCtx -&gt;FrameCount; n++) {
			m_pResizer -&gt;getRenderTarget( n ).Reset( );
			m_pWaiter -&gt;afterResetRenderTarget( n );
		}</span>
		// Determine the render target size in pixels.
<span style = "background-color:#fdd">		const UINT backBufferWidth = std::max&lt; UINT &gt;( width, 1u );
		const UINT backBufferHeight = std::max&lt; UINT &gt;( height, 1u );</span>

		// If the swap chain already exists, resize it.
<span style = "background-color:#fdd">        DXGI_SWAP_CHAIN_DESC desc = {};
        m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;GetDesc( &amp;desc );</span>
		//m_pWaiter -&gt;waitForGpu( );
<span style = "background-color:#fdd">		hr = m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;ResizeBuffers(</span>
				m_psstDxCtx -&gt;FrameCount
				, backBufferWidth
				, backBufferHeight
				, desc.BufferDesc.Format
				, desc.Flags // DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING
			);

		// Obtain the back buffers for this window which will be the final render targets
		// and create render target views for each of them.
<span style = "background-color:#fdd">		for (UINT n = 0; n &lt; m_psstDxCtx -&gt;FrameCount; n++)</span>
		{
<span style = "background-color:#fdd">			hr = m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;GetBuffer(</span>
					n
					, IID_PPV_ARGS( m_pResizer -&gt;getRenderTarget( n ).GetAddressOf( ) )
				);

<span style = "background-color:#fdd">			wchar_t name[25] = { };
			swprintf_s( name, L"Render target %u", n );
			m_pResizer -&gt;getRenderTarget( n ) -&gt;SetName( name );</span>

<span style = "background-color:#fdd">			auto cpuHandle = m_psstDxCtx -&gt;m_rtvHeap -&gt;GetCPUDescriptorHandleForHeapStart( );
			const CD3DX12_CPU_DESCRIPTOR_HANDLE rtvDescriptor(</span>
					cpuHandle
					, static_cast&lt; INT &gt;( n )
					, m_psstDxCtx -&gt;m_rtvDescriptorSize
				);
<span style = "background-color:#fdd">			m_psstDxCtx -&gt;m_pcD3dDevice12 -&gt;CreateRenderTargetView(</span>
						m_pResizer -&gt;getRenderTarget( n ).Get( )
					, nullptr
					, rtvDescriptor
				);
<span style = "background-color:#fdd">		}</span>

		// Reset the index to the current back buffer.
<span style = "background-color:#fdd">		m_pWaiter -&gt;set_frameIndex( m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;GetCurrentBackBufferIndex( ) );</span>

<span style = "background-color:#fdd">		m_pResizer -&gt;setViewport( CD3DX12_VIEWPORT( 0.0f, 0.0f, fWidth, fHeight ) );
		m_pResizer -&gt;setScissorRect( CD3DX12_RECT( 0, 0, lWidth, lHeight ) );</span>

		BOOL fullscreenState;
<span style = "background-color:#fdd">		hr = m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;GetFullscreenState( &amp;fullscreenState, nullptr );
		m_bWindowedMode = !fullscreenState;
	}
	void toggleFullscreenWindow() override {
		if ( !m_psstDxCtx ) 
			return;
		uptr&lt; lock_t &gt; scoped;
		if ( m_pMutex ) {
			scoped = std::make_unique&lt; lock_t &gt;( *m_pMutex );</span>
		}
<span style = "background-color:#fdd">		m_bIsToggleFullscreenWindow = true;
		sptr&lt;void&gt; resetFalse(nullptr, [&amp;](void*){ m_bIsToggleFullscreenWindow = false; });</span>


<span style = "background-color:#fdd">		Sys::Hr hr;
		auto stWndToken = AWndProcHolder::getWndToken( );
		HWND hWnd = stWndToken.m_hWnd;</span>
		// TODO: remakeme, lazy to make calling of parent ctor
<span style = "background-color:#fdd">		if ( m_stWindowRect == RECT{ } ) {
			m_stWindowRect = stWndToken.m_stWindowRect;
			m_uWindowStyle = stWndToken.m_uWindowStyle;</span>
		}

<span style = "background-color:#fdd">		if ( !m_psstDxCtx -&gt;detail_.m_bTearingSupport ) {</span>
            BOOL fullscreenState;
<span style = "background-color:#fdd">            hr = m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;GetFullscreenState( &amp;fullscreenState, nullptr );
            if ( FAILED( m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;SetFullscreenState( !fullscreenState, nullptr ) ) ) {</span>
                // Transitions to fullscreen mode can fail when running apps over
                // terminal services or for some other unexpected reason.  Consider
                // notifying the user in some way when this happens.
<span style = "background-color:#fdd">                Sys::ErrorHandler::showMsgAndExit( "Fullscreen transition failed" );</span>
            }
<span style = "background-color:#fdd">			return;</span>
        }

<span style = "background-color:#fdd">		if ( m_bFullscreenMode ) {</span>
			// Restore the window's attributes and size.
<span style = "background-color:#fdd">			::SetWindowLongW( hWnd, GWL_STYLE, m_uWindowStyle );
			::SetWindowPos(</span>
					hWnd
					, HWND_NOTOPMOST
					, m_stWindowRect.left
					, m_stWindowRect.top
					, m_stWindowRect.right - m_stWindowRect.left
					, m_stWindowRect.bottom - m_stWindowRect.top
					, SWP_FRAMECHANGED | SWP_NOACTIVATE
				);
			// Restore menu
<span style = "background-color:#fdd">			::SetMenu( hWnd, m_hMenu );
			::ShowWindow( hWnd, SW_NORMAL);
		}</span>
		else
		{
			// Save the old window rect so we can restore it when exiting fullscreen mode.
<span style = "background-color:#fdd">			::GetWindowRect( hWnd, &amp;m_stWindowRect );</span>
			// Make the window borderless so that the client area can fill the screen.
<span style = "background-color:#fdd">			::SetWindowLongW( hWnd, GWL_STYLE, m_uWindowStyle &amp; ~(WS_CAPTION | WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SYSMENU | WS_THICKFRAME));</span>
			// Remove menu
<span style = "background-color:#fdd">			m_hMenu = ::GetMenu( hWnd );
			::SetMenu( hWnd, NULL );</span>
			RECT fullscreenWindowRect;
			try
			{
				// Get the settings of the display on which the app's window is currently displayed
<span style = "background-color:#fdd">				CPtr&lt; IDXGIOutput &gt; pOutput;
				hr = m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;GetContainingOutput( pOutput.ReleaseAndGetAddressOf( ) );</span>
				DXGI_OUTPUT_DESC Desc;
<span style = "background-color:#fdd">				hr = pOutput -&gt;GetDesc( &amp;Desc );
				fullscreenWindowRect = Desc.DesktopCoordinates;
			}</span>
			catch (_com_error&amp; e)
<span style = "background-color:#fdd">			{</span>
				UNREFERENCED_PARAMETER( e );
				// Get the settings of the primary display
<span style = "background-color:#fdd">				DEVMODE devMode = { };
				devMode.dmSize = sizeof(DEVMODE);
				::EnumDisplaySettingsW( nullptr, ENUM_CURRENT_SETTINGS, &amp;devMode );
				fullscreenWindowRect = {</span>
						devMode.dmPosition.x
						, devMode.dmPosition.y
						, devMode.dmPosition.x + static_cast&lt;LONG&gt;(devMode.dmPelsWidth)
						, devMode.dmPosition.y + static_cast&lt;LONG&gt;(devMode.dmPelsHeight)
					};
<span style = "background-color:#fdd">			}</span>

<span style = "background-color:#fdd">			::SetWindowPos(</span>
					hWnd
					, HWND_TOPMOST
					, fullscreenWindowRect.left
					, fullscreenWindowRect.top
					, fullscreenWindowRect.right
					, fullscreenWindowRect.bottom
					, SWP_FRAMECHANGED | SWP_NOACTIVATE
				);
<span style = "background-color:#fdd">			::ShowWindow( hWnd, SW_MAXIMIZE);</span>
		}
<span style = "background-color:#fdd">		m_bFullscreenMode = !m_bFullscreenMode;
	}</span>

public:
	typedef uptr&lt; WindowResizer &gt; uptr_t;

	void setDxCtx(
		Ty::StDxCtx_crefPtr&lt; DxVer::v12 &gt; psstDxCtx
		, std::mutex *pMutex
		, Dx::Spec::D12::Waiter *pWaiter
		, Dx::Spec::D12::Resizer *pResizer
<span style = "background-color:#fdd">	) {
		m_psstDxCtx = psstDxCtx;
		m_pMutex = pMutex;
		m_pWaiter = pWaiter;
		m_pResizer = pResizer;
	}
	bool isWindowed() const {
		return m_bWindowedMode;
	}</span>
};
} // namespace prj_3d::HelloWinHlsl::Dx::Spec::D12</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>