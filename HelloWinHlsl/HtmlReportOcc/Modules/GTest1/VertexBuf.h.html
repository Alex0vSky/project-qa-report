<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>VertexBuf.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Tool/VertexBuf.h - Vertex Buffer creator
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Tool {

template&lt;class TSPE,class T&gt; class VertexBuf; // primary template

template&lt;class T2&gt; class VertexBuf&lt;DxVer::v9,T2&gt; {
	using TInnerDxVer = DxVer::v9; // IntelliSense
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	typedef uptr&lt; VertexBuf &gt; uptr_t;
	explicit VertexBuf(
		Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	struct OutVertexBuf {
		const CPtr&lt; IDirect3DVertexBuffer9 &gt; m_pcBuffer;
		const DWORD m_dwFVF;
		const UINT m_uStride;
	};

	// Coordinate system handednesses is LH(left-handed)
	// Position/coordinate values in Ndc(Normalized device coordinate)
	// With D3DPOOL::D3DPOOL_DEFAULT and FVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE
	template&lt;class TVE&gt;
	auto createInitialized(const std::vector&lt; TVE &gt; &amp;veMemNdcLH, bool bNdc = true) {
		// TODO: std::enable_if_v&lt; is_same_t&lt; TVE, Tool::Vertex&lt;TInnerDxVer&gt; &gt; &gt;

		// From Ndc LH to Orth LH. @insp https://stackoverflow.com/questions/19226156/directx-11-vertices-coordinates @insp https://stackoverflow.com/questions/42751427/transformations-from-pixels-to-ndc
		D3DVIEWPORT9 stViewport = { };
		m_stDxCtx -&gt;m_pcD3dDevice -&gt;GetViewport( &amp;stViewport );
		std::vector&lt; TVE &gt; veMemOrthLH = veMemNdcLH;
		if ( bNdc ) 
			for ( TVE &amp;el : veMemOrthLH )
				el.xyz.x = ( ( stViewport.Width * ( 1 + el.xyz.x ) / 2.0f ) ), el.xyz.y = ( ( stViewport.Height * ( 1 - el.xyz.y ) / 2.0f ) );

		CPtr&lt; IDirect3DVertexBuffer9 &gt; cpVertexBuf;
		size_t si = veMemOrthLH.size( ) * sizeof( TVE );
		DWORD dwFVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE;
		DWORD dwUsage = 0;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateVertexBuffer( 
				(UINT)si
                , dwUsage, dwFVF
                , D3DPOOL_DEFAULT, cpVertexBuf.ReleaseAndGetAddressOf( ), NULL
			);
		if ( FAILED( hr ) )
			return uptr&lt; OutVertexBuf &gt;{ }; // nullptr;
		void *pVertices;
		hr = cpVertexBuf -&gt;Lock( 0, (UINT)si, &amp;pVertices, 0 );
		if ( FAILED( hr ) )
			return uptr&lt; OutVertexBuf &gt;{ }; // nullptr;
		memcpy( pVertices, &amp;veMemOrthLH[ 0 ], si );
		cpVertexBuf -&gt;Unlock();

		OutVertexBuf stBuf{ 
				cpVertexBuf 
				, dwFVF
				, sizeof( TVE )
			};
		return std::make_unique&lt; OutVertexBuf &gt;( stBuf );
	}
};

template&lt;class T&gt; class VertexBuf&lt;DxVer::v10,T&gt; {
	const Ty::StDxCtx_ptr&lt;T&gt; m_stDxCtx;
public:
	typedef uptr&lt; VertexBuf &gt; uptr_t;
	explicit VertexBuf(
		Ty::StDxCtx_crefPtr&lt;T&gt; stDxCtx
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	struct OutVertexBuf {
		static const UINT c_uNumBuffers = 1;
		const CPtr&lt; ID3D10Buffer &gt; m_pcBuffer;
		const std::vector&lt; ID3D10Buffer *&gt; m_veBuffers;
		const std::vector&lt; UINT &gt; m_veStride;
		const std::vector&lt; UINT &gt; m_veOffset;
	};	

	// Coordinate system handednesses is LH(left-handed)
	// Position/coordinate values in Ndc(Normalized device coordinate)
	// using D3D10_BIND_VERTEX_BUFFER flag
	template&lt;class TVE&gt;
	auto createInitialized(const std::vector&lt; TVE &gt; &amp;veMemNdcLH) {
		D3D10_SUBRESOURCE_DATA stInitData = { &amp;veMemNdcLH[0] };
		D3D10_BUFFER_DESC stBufferDesc = { };
		stBufferDesc.ByteWidth = (UINT)( sizeof( TVE ) * veMemNdcLH.size( ) );
		stBufferDesc.Usage = D3D10_USAGE_DEFAULT;
		stBufferDesc.BindFlags = D3D10_BIND_VERTEX_BUFFER;
		CPtr&lt; ID3D10Buffer &gt; cpVertexBuf;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateBuffer( &amp;stBufferDesc, &amp;stInitData, cpVertexBuf.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return uptr&lt; OutVertexBuf &gt;{ }; // nullptr;
		OutVertexBuf stBuf{ 
				cpVertexBuf 
				, { cpVertexBuf.Get( ) }
				, { sizeof( TVE ) }
				, { 0 }
			};
		return std::make_unique&lt; OutVertexBuf &gt;( stBuf );
	}
};

template&lt;class T&gt; class VertexBuf&lt;DxVer::v11,T&gt; {
	const Ty::StDxCtx_ptr&lt;T&gt; m_stDxCtx;
public:
	typedef uptr&lt; VertexBuf &gt; uptr_t;
	explicit VertexBuf(
		Ty::StDxCtx_crefPtr&lt;T&gt; stDxCtx
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	struct OutVertexBuf {
		static const UINT c_uNumBuffers = 1;
		const CPtr&lt; ID3D11Buffer &gt; m_pcBuffer;
		const std::vector&lt; ID3D11Buffer *&gt; m_veBuffers;
		const std::vector&lt; UINT &gt; m_veStride;
		const std::vector&lt; UINT &gt; m_veOffset;
	};	

	// Coordinate system handednesses is LH(left-handed)
	// Position/coordinate values in Ndc(Normalized device coordinate)
	// using D3D10_BIND_VERTEX_BUFFER flag
	template&lt;class TVE&gt;
	auto createInitialized(const std::vector&lt; TVE &gt; &amp;veMemNdcLH) {
		D3D11_SUBRESOURCE_DATA stInitData = { &amp;veMemNdcLH[0] };
		D3D11_BUFFER_DESC stBufferDesc = { };
		stBufferDesc.ByteWidth = (UINT)( sizeof( TVE ) * veMemNdcLH.size( ) );
		stBufferDesc.Usage = D3D11_USAGE_DEFAULT;
		stBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		CPtr&lt; ID3D11Buffer &gt; cpVertexBuf;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateBuffer( &amp;stBufferDesc, &amp;stInitData, cpVertexBuf.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return uptr&lt; OutVertexBuf &gt;{ }; // nullptr;
		OutVertexBuf stBuf{ 
				cpVertexBuf 
				, { cpVertexBuf.Get( ) }
				, { sizeof( TVE ) }
				, { 0 }
			};
		return std::make_unique&lt; OutVertexBuf &gt;( stBuf );
	}
};

template&lt;class T&gt; class VertexBuf&lt;DxVer::v12,T&gt; {
	const Ty::StDxCtx_ptr&lt;T&gt; m_stDxCtx;
public:
	typedef uptr&lt; VertexBuf &gt; uptr_t;
	explicit VertexBuf(
		Ty::StDxCtx_crefPtr&lt;T&gt; stDxCtx
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	struct OutVertexBuf {
		static const UINT c_uNumBuffers = 1;
		const CPtr&lt; ID3D12Resource &gt; m_pcBuffer;
		const D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;
	};	

	// Coordinate system handednesses is LH(left-handed)
	// Position/coordinate values in Ndc(Normalized device coordinate)
	template&lt;class TVE&gt;
	auto createInitialized(const std::vector&lt; TVE &gt; &amp;veMemNdcLH) {

		HRESULT hr;
		CPtr&lt; ID3D12Resource &gt; vertexBuffer;
		D3D12_VERTEX_BUFFER_VIEW vertexBufferView;

		const UINT vertexBufferSize = (UINT)Tpl::Trait::vectorsizeof( veMemNdcLH );
		CD3DX12_HEAP_PROPERTIES stHeapProp( D3D12_HEAP_TYPE_UPLOAD );
		CD3DX12_RESOURCE_DESC stResDesc = CD3DX12_RESOURCE_DESC::Buffer( vertexBufferSize, D3D12_RESOURCE_FLAG_NONE );
		// Note: using upload heaps to transfer static data like vert buffers is not 
		// recommended. Every time the GPU needs it, the upload heap will be marshalled 
		// over. Please read up on Default Heap usage. An upload heap is used here for 
		// code simplicity and because there are very few verts to actually transfer.
		hr = m_stDxCtx -&gt;m_pcD3dDevice12 -&gt;CreateCommittedResource(
				&amp;stHeapProp
				, D3D12_HEAP_FLAG_NONE // ? NVIDIA man D3D12_HEAP_FLAG_CREATE_NOT_ZEROED
				, &amp;stResDesc
				, D3D12_RESOURCE_STATE_GENERIC_READ
				, nullptr
				, IID_PPV_ARGS( vertexBuffer.ReleaseAndGetAddressOf( ) )
			);
		if ( FAILED( hr ) )
			return uptr&lt; OutVertexBuf &gt;{ }; // nullptr;

		// Copy the triangle data to the vertex buffer.
		UINT8* pVertexDataBegin;
		CD3DX12_RANGE readRange( 0, 0 );        // We do not intend to read from this resource on the CPU.
		hr = vertexBuffer -&gt;Map( 0, &amp;readRange, reinterpret_cast&lt;void**&gt;( &amp;pVertexDataBegin ) );
		if ( FAILED( hr ) )
			return uptr&lt; OutVertexBuf &gt;{ }; // nullptr;
		memcpy( pVertexDataBegin, veMemNdcLH.data( ), Tpl::Trait::vectorsizeof( veMemNdcLH ) );
		vertexBuffer -&gt;Unmap( 0, nullptr );

		// Initialize the vertex buffer view.
		vertexBufferView.BufferLocation = vertexBuffer -&gt;GetGPUVirtualAddress( );
		vertexBufferView.StrideInBytes = sizeof( TVE );
		vertexBufferView.SizeInBytes = vertexBufferSize;

		OutVertexBuf stBuf{ 
				vertexBuffer
				, vertexBufferView
			};
		return std::make_unique&lt; OutVertexBuf &gt;( stBuf );
	}
};
} // namespace prj_3d::HelloWinHlsl::Dx::Tool</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>