<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Quad.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Tool/Predef/Quad.h - helper for creating a square of vertices for shaders to work there.
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Tool::Predef {

template&lt;class T&gt; class Quad; // primary template

template&lt;&gt; class Quad&lt;DxVer::v9&gt; {
	using TInnerDxVer = DxVer::v9;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
	const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; m_psoVertexBuf;
public:
	Quad(
		Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx
		, const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; &amp;psoVertexBuf
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
		, m_psoVertexBuf( psoVertexBuf )
	{}</span>

	struct vertexBufPrimitive_t {
		VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf m_stVertexBuf;
		static const Tool::Vertex&lt;TInnerDxVer&gt; typeForLayout;
		const D3DPRIMITIVETYPE m_enuPrimitiveType;
		const UINT m_uStartVertex;
		const UINT m_uPrimitiveCount;
		const UINT m_uStride;
	};
	auto createVertexBuf() {
		static const D3DCOLOR colorCyan = D3DCOLOR_XRGB( 0, 255, 255 ); // LightSaturatedCyan
		static const D3DCOLOR colorRed = D3DCOLOR_XRGB( 255, 0, 0 );
		static const D3DCOLOR colorGreen = D3DCOLOR_XRGB( 0, 255, 0 );
		static const D3DCOLOR colorYellow = D3DCOLOR_XRGB( 255, 255, 0 );
		float z = 0;
		float rhw = 1.0f;
		// Fill vertex buffer
		std::vector&lt; Tool::Vertex&lt;TInnerDxVer&gt; &gt; veMem = {
				{ D3DXVECTOR3( -1, -1, z ),	rhw,	colorCyan	},	// bottom left corner
				{ D3DXVECTOR3( -1, +1, z ),	rhw,	colorRed	},	// top left corner
				{ D3DXVECTOR3( +1, -1, z ),	rhw,	colorGreen	},	// bottom right corner
				{ D3DXVECTOR3( +1, +1, z ),	rhw,	colorYellow	},	// top right corner
			};
		auto pust = m_psoVertexBuf -&gt;createInitialized( veMem );
		if ( !pust )
			return uptr&lt; vertexBufPrimitive_t &gt;{ }; // nullptr;
		
		vertexBufPrimitive_t stBuf{
				VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf{
					pust -&gt;m_pcBuffer
					, pust -&gt;m_dwFVF
				}
				, D3DPT_TRIANGLESTRIP
				, 0
				, (UINT)veMem.size( ) - 1
				, (UINT)sizeof( Vertex&lt;TInnerDxVer&gt; )
			};
		return std::make_unique&lt; vertexBufPrimitive_t &gt;( stBuf );
	}
};

template&lt;&gt; class Quad&lt;DxVer::v10&gt; {
	using TInnerDxVer = DxVer::v10;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
	const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; m_psoVertexBuf;
public:
	Quad(
		Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx
		, const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; &amp;psoVertexBuf
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
		, m_psoVertexBuf( psoVertexBuf )
	{}</span>

	CPtr&lt; ID3D10InputLayout &gt; createLayout(const std::vector&lt;char&gt; &amp;veShaderByte) {
		CPtr&lt; ID3D10InputLayout &gt; cpLayout;
		D3D10_INPUT_ELEMENT_DESC stLayout[] = { 
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 }
			};
		m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateInputLayout( stLayout, _countof( stLayout ), &amp;veShaderByte[ 0 ], veShaderByte.size( ), cpLayout.ReleaseAndGetAddressOf( ) );
		return cpLayout;
	}
	struct vertexBufTopology_t {
		VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf m_stVertexBuf;
		D3D_PRIMITIVE_TOPOLOGY m_enuTopology;
	};	
	auto createVertexBuf() {
		// TODO: common data to base class, now its common sure
		// TODO: take type from Tool::VertexBuf&lt;TInnerDxVer&gt;:: ...
		// Fill vertex buffer. Enough "D3DXVECTOR3", expects "D3DXVECTOR4", definition goes by "stride" in "IASetVertexBuffers".
		std::vector&lt; D3DXVECTOR3 &gt; veMem = {
				  D3DXVECTOR3( -1, -1, 0 ) // bottom left corner
				, D3DXVECTOR3( -1, +1, 0 ) // top left corner
				, D3DXVECTOR3( +1, -1, 0 ) // bottom right corner
				, D3DXVECTOR3( +1, +1, 0 ) // top right corner
			};
		auto pust = m_psoVertexBuf -&gt;createInitialized( veMem );
		if ( !pust )
			return uptr&lt; vertexBufTopology_t &gt;{ }; // nullptr;
		vertexBufTopology_t stBuf{
				VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf{
					pust -&gt;m_pcBuffer
					, pust -&gt;m_veBuffers
					, pust -&gt;m_veStride
					, pust -&gt;m_veOffset
				}
				, D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
			};
		return std::make_unique&lt; vertexBufTopology_t &gt;( stBuf );
	}
};

template&lt;&gt; class Quad&lt;DxVer::v11&gt; {
	using TInnerDxVer = DxVer::v11;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
	const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; m_psoVertexBuf;
public:
	Quad(
		Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx
		, const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; &amp;psoVertexBuf
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
		, m_psoVertexBuf( psoVertexBuf )
	{}</span>

	CPtr&lt; ID3D11InputLayout &gt; createLayout(const std::vector&lt;char&gt; &amp;veShaderByte) {
		CPtr&lt; ID3D11InputLayout &gt; cpLayout;
		D3D11_INPUT_ELEMENT_DESC stLayout[] = { 
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 }
			};
		m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateInputLayout( stLayout, _countof( stLayout ), &amp;veShaderByte[ 0 ], veShaderByte.size( ), cpLayout.ReleaseAndGetAddressOf( ) );
		return cpLayout;
	}
	struct vertexBufTopology_t {
		VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf m_stVertexBuf;
		D3D_PRIMITIVE_TOPOLOGY m_enuTopology;
	};	
	auto createVertexBuf() {
		// Fill vertex buffer. Enough "D3DXVECTOR3", expects "D3DXVECTOR4", definition goes by "stride" in "IASetVertexBuffers".
		std::vector&lt; D3DXVECTOR3 &gt; veMem = {
				  D3DXVECTOR3( -1, -1, 0 ) // bottom left corner
				, D3DXVECTOR3( -1, +1, 0 ) // top left corner
				, D3DXVECTOR3( +1, -1, 0 ) // bottom right corner
				, D3DXVECTOR3( +1, +1, 0 ) // top right corner
			};
		auto pust = m_psoVertexBuf -&gt;createInitialized( veMem );
		if ( !pust )
			return uptr&lt; vertexBufTopology_t &gt;{ }; // nullptr;
		vertexBufTopology_t stBuf{
				VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf{
					pust -&gt;m_pcBuffer
					, pust -&gt;m_veBuffers
					, pust -&gt;m_veStride
					, pust -&gt;m_veOffset
				}
				, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
			};
		return std::make_unique&lt; vertexBufTopology_t &gt;( stBuf );
	}
};

template&lt;&gt; class Quad&lt;DxVer::v12&gt; {
	using TInnerDxVer = DxVer::v12;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
	const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; m_psoVertexBuf;
public:
	Quad(
		Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx
		, const sptr&lt; Tool::VertexBuf&lt;TInnerDxVer&gt; &gt; &amp;psoVertexBuf
	) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
		, m_psoVertexBuf( psoVertexBuf )
	{}</span>

	std::vector&lt; D3D12_INPUT_ELEMENT_DESC &gt; createLayout() {
		std::vector&lt; D3D12_INPUT_ELEMENT_DESC &gt; vecLayout = { 
				{ "POSITION", 0
					, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT
					, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }
			};
		return vecLayout;
	}
	struct vertexBufTopology_t {
		VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf m_stVertexBuf;
		D3D_PRIMITIVE_TOPOLOGY m_enuTopology;
	};	
	auto createVertexBuf() {
		// Fill vertex buffer
		std::vector&lt; D3DXVECTOR3 &gt; veMem = {
				  D3DXVECTOR3( -1, -1, 0 ) // bottom left corner
				, D3DXVECTOR3( -1, +1, 0 ) // top left corner
				, D3DXVECTOR3( +1, -1, 0 ) // bottom right corner
				, D3DXVECTOR3( +1, +1, 0 ) // top right corner
			};
		auto pust = m_psoVertexBuf -&gt;createInitialized( veMem );
		if ( !pust )
			return uptr&lt; vertexBufTopology_t &gt;{ }; // nullptr;
		vertexBufTopology_t stBuf{
				VertexBuf&lt;TInnerDxVer&gt;::OutVertexBuf{
					pust -&gt;m_pcBuffer
					, pust -&gt;m_vertexBufferView
				}
				, D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
			};
		return std::make_unique&lt; vertexBufTopology_t &gt;( stBuf );
	}
};
} // namespace prj_3d::HelloWinHlsl::Dx::Tool::Predef</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>