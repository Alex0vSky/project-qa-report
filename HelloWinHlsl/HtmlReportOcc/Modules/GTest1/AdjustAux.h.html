<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>AdjustAux.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/AdjustAux.h - setting auxiliary DirectX features via callback
#pragma once

// TODO: avoid need create spectial data struct for client
// Fwd decl for friend-s
namespace prj_3d::HelloWinHlsl::GameLoop {
namespace detail_ { template&lt;class T, class TWndProcHolder&gt; class ABase; }
} // namespace prj_3d::HelloWinHlsl::GameLoop
namespace prj_3d::HelloWinHlsl::Dx::Spec::D12 { 
class GameLoopPart;
} // namespace prj_3d::HelloWinHlsl::Dx::Spec::D12

namespace prj_3d::HelloWinHlsl::Dx { 

template&lt;class T&gt; class AdjustAux; // primary template

template&lt;&gt; class AdjustAux&lt;DxVer::v9&gt; { 
	using TInnerDxVer = DxVer::v9;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_psstDxCtx;
public:
    typedef uptr&lt; AdjustAux &gt; uptr_t;
	explicit AdjustAux(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; psstDxCtx) 
<span style = "background-color:#fdd">		: m_psstDxCtx( psstDxCtx )
	{ }</span>

	// ?TODO: make me?
<span style = "background-color:#fdd">	void adjust() {
	}</span>
};
template&lt;&gt; class AdjustAux&lt;DxVer::v10&gt; { 
	using TInnerDxVer = DxVer::v10;

	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_psstDxCtx;

	// TODO: store in CPtr, because user can release memory
	//	@use C:\Prj\3d\HelloShader\poc\withoutEffects\main.cpp
	ID3D10RasterizerState** m_pifcRasterizerStateUser;
	std::function&lt; void (D3D10_RASTERIZER_DESC *) &gt; m_pfnRasterizerState;

	ID3D10DepthStencilState** m_pifcDepthStencilStateUser;
	std::function&lt; void (D3D10_DEPTH_STENCIL_DESC *) &gt; m_pfnDepthStencilState;

	ID3D10BlendState** m_pifcBlendStateUser;
	std::function&lt; void (D3D10_BLEND_DESC *) &gt; m_pfnBlendState;

	ID3D10DepthStencilView** m_pifcID3D10DepthStencilViewUser;
	std::function&lt; void (D3D10_TEXTURE2D_DESC *,D3D10_DEPTH_STENCIL_VIEW_DESC *) &gt; m_pfnDepthStencilView;
	
public:
    typedef uptr&lt; AdjustAux &gt; uptr_t;
	explicit AdjustAux(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; psstDxCtx) 
<span style = "background-color:#fdd">		: m_psstDxCtx( psstDxCtx )
		, m_pifcRasterizerStateUser( nullptr )
		, m_pifcDepthStencilStateUser( nullptr )
		, m_pifcBlendStateUser( nullptr )
		, m_pifcID3D10DepthStencilViewUser( nullptr )
    {}</span>

	// Why "decltype" and heavy function type -- 
// stackoverflow.com/questions/28509273/get-types-of-c-function-parameters
	void setRasterizerState(ID3D10RasterizerState** pifc, decltype(m_pfnRasterizerState) pfn = nullptr) {
		m_pifcRasterizerStateUser = pifc;
		m_pfnRasterizerState = pfn;
	}
	void setDepthStencilState(ID3D10DepthStencilState** pifc, decltype(m_pfnDepthStencilState) pfn = nullptr) {
		m_pifcDepthStencilStateUser = pifc;
		m_pfnDepthStencilState = pfn;
	}
	void setBlendState(ID3D10BlendState** pifc, decltype(m_pfnBlendState) pfn = nullptr) {
		m_pifcBlendStateUser = pifc;
		m_pfnBlendState = pfn;
	}
	void setDepthStencilView(ID3D10DepthStencilView** pifc, decltype(m_pfnDepthStencilView) pfn = nullptr) {
		m_pifcID3D10DepthStencilViewUser = pifc;
		m_pfnDepthStencilView = pfn;
	}
	// TODO: can take values ââlike default "DXUT" from "DXUTSetupD3D10Views" code. Now most of '...\HLSLWithoutFX10\HLSLWithoutFX10.cpp'.
<span style = "background-color:#fdd">	void adjust() {
        Sys::Hr hr;</span>
		// Set up rasterizer
<span style = "background-color:#fdd">		if ( m_pifcRasterizerStateUser ) {</span>
			// TODO: you need to make your own "memset", because it is "{ 0 }", does not guarantee nulling.
			// @insp https://stackoverflow.com/questions/61240589/how-to-initialize-a-struct-to-0-in-c
<span style = "background-color:#fdd">			D3D10_RASTERIZER_DESC stD3dRasterizerDesc = {};
			stD3dRasterizerDesc.AntialiasedLineEnable = FALSE;
			stD3dRasterizerDesc.CullMode = D3D10_CULL_NONE;
			stD3dRasterizerDesc.DepthBias = 0;
			stD3dRasterizerDesc.DepthBiasClamp = 0;
			stD3dRasterizerDesc.DepthClipEnable = TRUE;
			stD3dRasterizerDesc.FillMode = D3D10_FILL_SOLID;
			stD3dRasterizerDesc.FrontCounterClockwise = FALSE; // Must be FALSE for 10on9
			stD3dRasterizerDesc.MultisampleEnable = FALSE;
			stD3dRasterizerDesc.ScissorEnable = FALSE;
			stD3dRasterizerDesc.SlopeScaledDepthBias = 0;
			if ( m_pfnRasterizerState ) 
				m_pfnRasterizerState( &amp;stD3dRasterizerDesc );
			CPtr&lt;ID3D10RasterizerState&gt; pcRasterizerStateDef;
			hr = m_psstDxCtx -&gt;m_pcD3dDevice -&gt;CreateRasterizerState( &amp;stD3dRasterizerDesc, pcRasterizerStateDef.ReleaseAndGetAddressOf( ) );
			*m_pifcRasterizerStateUser = pcRasterizerStateDef.Detach( );
		}</span>
		// Create a depth stencil state to enable less-equal depth testing
<span style = "background-color:#fdd">		if ( m_pifcDepthStencilStateUser ) {
			D3D10_DEPTH_STENCIL_DESC stDSDesc = {};
			stDSDesc.DepthEnable = TRUE;
			stDSDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;
			stDSDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ALL;
			if ( m_pfnDepthStencilState ) 
				m_pfnDepthStencilState( &amp;stDSDesc );
			CPtr&lt;ID3D10DepthStencilState&gt; pcLessEqualDepth;
			hr = m_psstDxCtx -&gt;m_pcD3dDevice -&gt;CreateDepthStencilState( &amp;stDSDesc, pcLessEqualDepth.ReleaseAndGetAddressOf( ) );
			*m_pifcDepthStencilStateUser = pcLessEqualDepth.Detach( );
		}</span>
		// Create a blend state to disable alpha blending
<span style = "background-color:#fdd">		if ( m_pifcBlendStateUser ) </span>
		{
<span style = "background-color:#fdd">			D3D10_BLEND_DESC stBlendState = {};
			stBlendState.BlendEnable[0] = FALSE;
			stBlendState.RenderTargetWriteMask[0] = D3D10_COLOR_WRITE_ENABLE_ALL;
			if ( m_pfnBlendState ) 
				m_pfnBlendState( &amp;stBlendState );
			CPtr&lt;ID3D10BlendState&gt; pcBlendStateNoBlend;
			hr = m_psstDxCtx -&gt;m_pcD3dDevice -&gt;CreateBlendState( &amp;stBlendState, pcBlendStateNoBlend.ReleaseAndGetAddressOf( ) );
			*m_pifcBlendStateUser = pcBlendStateNoBlend.Detach( );
		}</span>

		// Sets the viewport, creates a render target view, and depth scencil texture and view. @insp HRESULT DXUTSetupD3D10Views( ID3D10Device* pd3dDevice, DXUTDeviceSettings* pDeviceSettings )
<span style = "background-color:#fdd">		if ( m_pifcID3D10DepthStencilViewUser ) {</span>
			// Get the back buffer and desc
			D3D10_TEXTURE2D_DESC stBackBufferSurfaceDesc;
			{
<span style = "background-color:#fdd">				CPtr&lt;ID3D10Texture2D&gt; pBackBuffer;
				hr = m_psstDxCtx -&gt;m_pcDxgiSwapChain -&gt;GetBuffer( </span>
						0
						, IID_PPV_ARGS( pBackBuffer.ReleaseAndGetAddressOf( ) )
					);
<span style = "background-color:#fdd">				pBackBuffer-&gt;GetDesc( &amp;stBackBufferSurfaceDesc );
			}</span>
			// Create depth stencil texture
<span style = "background-color:#fdd">			CPtr&lt;ID3D10Texture2D&gt; pcDepthStencil;
			D3D10_TEXTURE2D_DESC stTex2dDesc = {};
			stTex2dDesc.Width = stBackBufferSurfaceDesc.Width;
			stTex2dDesc.Height = stBackBufferSurfaceDesc.Height;
			stTex2dDesc.MipLevels = 1;
			stTex2dDesc.ArraySize = 1;</span>
			// @insp ...\DXUT\Core\DXUTenum.cpp. DXUTBuildOptimalD3D10DeviceSettings() -&gt; DXUTBuildValidD3D10DeviceSettings() -&gt;bestMultiSampleCount
<span style = "background-color:#fdd">			stTex2dDesc.Format = DXGI_FORMAT_D32_FLOAT; // pDeviceSettings-&gt;d3d10.AutoDepthStencilFormat;
			stTex2dDesc.SampleDesc.Count = 1; // pDeviceSettings-&gt;d3d10.sd.SampleDesc.Count;
			stTex2dDesc.SampleDesc.Quality = 0; // pDeviceSettings-&gt;d3d10.sd.SampleDesc.Quality;
			stTex2dDesc.Usage = D3D10_USAGE_DEFAULT;
			stTex2dDesc.BindFlags = D3D10_BIND_DEPTH_STENCIL;
			stTex2dDesc.CPUAccessFlags = 0;
			stTex2dDesc.MiscFlags = 0;</span>

			// Create the depth stencil view
<span style = "background-color:#fdd">			D3D10_DEPTH_STENCIL_VIEW_DESC stDsvDesc = {};
			stDsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
			stDsvDesc.ViewDimension = D3D10_DSV_DIMENSION_TEXTURE2D;
			stDsvDesc.Texture2D.MipSlice = 0;</span>

<span style = "background-color:#fdd">			if ( m_pfnDepthStencilView ) 
				m_pfnDepthStencilView( &amp;stTex2dDesc, &amp;stDsvDesc );
			hr = m_psstDxCtx -&gt;m_pcD3dDevice -&gt;CreateTexture2D( &amp;stTex2dDesc, NULL, pcDepthStencil.ReleaseAndGetAddressOf( ) );
			CPtr&lt;ID3D10DepthStencilView&gt; pcDSV;
			hr = m_psstDxCtx -&gt;m_pcD3dDevice -&gt;CreateDepthStencilView( pcDepthStencil.Get( ), &amp;stDsvDesc, pcDSV.ReleaseAndGetAddressOf( ) );
			*m_pifcID3D10DepthStencilViewUser = pcDSV.Detach( );
		}
	}</span>
};
// TODO: cleanme
template&lt;&gt; class AdjustAux&lt;DxVer::v11&gt; { 
	using TInnerDxVer = DxVer::v11;

	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_psstDxCtx;

	// TODO: store in CPtr, because user can release memory
	//	@use C:\Prj\3d\HelloShader\poc\withoutEffects\main.cpp
	ID3D10RasterizerState** m_pifcRasterizerStateUser;
	std::function&lt; void (D3D10_RASTERIZER_DESC *) &gt; m_pfnRasterizerState;

	ID3D10DepthStencilState** m_pifcDepthStencilStateUser;
	std::function&lt; void (D3D10_DEPTH_STENCIL_DESC *) &gt; m_pfnDepthStencilState;

	ID3D10BlendState** m_pifcBlendStateUser;
	std::function&lt; void (D3D10_BLEND_DESC *) &gt; m_pfnBlendState;

	ID3D10DepthStencilView** m_pifcID3D10DepthStencilViewUser;
	std::function&lt; void (D3D10_TEXTURE2D_DESC *,D3D10_DEPTH_STENCIL_VIEW_DESC *) &gt; m_pfnDepthStencilView;
	
public:
    typedef uptr&lt; AdjustAux &gt; uptr_t;
	explicit AdjustAux(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; psstDxCtx) 
<span style = "background-color:#fdd">		: m_psstDxCtx( psstDxCtx )
		, m_pifcRasterizerStateUser( nullptr )
		, m_pifcDepthStencilStateUser( nullptr )
		, m_pifcBlendStateUser( nullptr )
		, m_pifcID3D10DepthStencilViewUser( nullptr )
    {}</span>

	// Why "decltype" and heavy function type -- 
// stackoverflow.com/questions/28509273/get-types-of-c-function-parameters
	void setRasterizerState(ID3D10RasterizerState** pifc, decltype(m_pfnRasterizerState) pfn = nullptr) {
		m_pifcRasterizerStateUser = pifc;
		m_pfnRasterizerState = pfn;
	}
	void setDepthStencilState(ID3D10DepthStencilState** pifc, decltype(m_pfnDepthStencilState) pfn = nullptr) {
		m_pifcDepthStencilStateUser = pifc;
		m_pfnDepthStencilState = pfn;
	}
	void setBlendState(ID3D10BlendState** pifc, decltype(m_pfnBlendState) pfn = nullptr) {
		m_pifcBlendStateUser = pifc;
		m_pfnBlendState = pfn;
	}
	void setDepthStencilView(ID3D10DepthStencilView** pifc, decltype(m_pfnDepthStencilView) pfn = nullptr) {
		m_pifcID3D10DepthStencilViewUser = pifc;
		m_pfnDepthStencilView = pfn;
	}
<span style = "background-color:#fdd">	void adjust() {
	}</span>
};
template&lt;&gt; class AdjustAux&lt;DxVer::v12&gt; { 
	using TInnerDxVer = DxVer::v12;

	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_psstDxCtx;

	std::function&lt; void (D3D12_GRAPHICS_PIPELINE_STATE_DESC *) &gt; m_pfnChangePso;

	Dx::Spec::D12::Waiter *m_pWaiter;
	Dx::Spec::D12::SetterRootSignature m_setterRootSignature;
	CPtr&lt; ID3D12PipelineState &gt; m_pcPipelineState;
	CPtr&lt; ID3D12GraphicsCommandList &gt; m_pc_CommandList;

public:
    typedef uptr&lt; AdjustAux &gt; uptr_t;
	AdjustAux(
			Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; psstDxCtx
			, Dx::Spec::D12::Waiter *psoWaiter
			, Dx::Spec::D12::SetterRootSignature::cref_t setterRootSignature
		) 
<span style = "background-color:#fdd">		: m_psstDxCtx( psstDxCtx )
		, m_pWaiter( psoWaiter )
		, m_setterRootSignature( setterRootSignature )
    {}</span>

	void onSetPso(decltype( m_pfnChangePso ) pfn) {
		m_pfnChangePso = pfn;
	}

 private:
	friend class GameLoop::detail_::ABase&lt; DxVer::v12, Dx::Spec::Any::WindowResizerStub &gt;;
	friend class GameLoop::detail_::ABase&lt; DxVer::v12, Dx::Spec::D12::WindowResizer &gt;;
<span style = "background-color:#fdd">	void adjust() {
        Sys::Hr hr;</span>
		// part2 Create the pipeline state, which includes compiling and loading shaders.
<span style = "background-color:#fdd">		D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = m_psstDxCtx -&gt;m_psoDesc;
		if ( m_pfnChangePso ) {
			m_pfnChangePso( &amp;psoDesc );
			if ( m_psstDxCtx -&gt;m_initialRootSignature.Get( ) != psoDesc.pRootSignature ) {
				m_setterRootSignature.set( psoDesc.pRootSignature );</span>
			}
		}

<span style = "background-color:#fdd">		hr = m_psstDxCtx -&gt;m_pcD3dDevice12 -&gt;CreateGraphicsPipelineState( </span>
				&amp;psoDesc
				, IID_PPV_ARGS( m_pcPipelineState.ReleaseAndGetAddressOf( ) )
			);

		// Create the command list.
<span style = "background-color:#fdd">		hr = m_psstDxCtx -&gt;m_pcD3dDevice12 -&gt;CreateCommandList( </span>
				0
				, D3D12_COMMAND_LIST_TYPE_DIRECT
				, m_psstDxCtx -&gt;m_arpcCommandAllocators[ m_pWaiter -&gt;get_frameIndex( ) ].Get( )
				, m_pcPipelineState.Get( )
				, IID_PPV_ARGS( m_pc_CommandList.ReleaseAndGetAddressOf( ) )
			);
		// Command lists are created in the recording state, but there is nothing
		// to record yet. The main loop expects it to be closed, so close it now.
<span style = "background-color:#fdd">		hr = m_pc_CommandList -&gt;Close( );</span>

		// Wait for the command list to execute; we are reusing the same command 
		// list in our main loop but for now, we just want to wait for setup to 
		// complete before continuing.
<span style = "background-color:#fdd">		m_pWaiter -&gt;waitForGpu( );
	}</span>

 private:
	friend class Dx::Spec::D12::GameLoopPart;
<span style = "background-color:#fdd">	auto getPipelineState() {
		return m_pcPipelineState;
	}
	auto getCommandList() {
		return m_pc_CommandList;
	}</span>
};

namespace detail_ {
<span style = "background-color:#fdd">template&lt;class T, typename... Args&gt; static auto z_make_unique(Args&amp;&amp;... args) {
	return std::make_unique&lt; Tpl::Trait::aggregate_adapter&lt; AdjustAux&lt; T &gt; &gt; &gt;( </span>
		std::forward&lt;Args&gt;(args)... );
<span style = "background-color:#fdd">}</span>
} // namespace detail_ _

// Factory of AdjustAux. To fork call ctors. primary template, "typename = void" for partial specialization
template&lt;class T, typename = void&gt; struct FactoryAdjustAux;

// the partial specialization other Dx
template&lt;class T&gt; 
struct FactoryAdjustAux&lt;T&gt; {
	static
<span style = "background-color:#fdd">	auto create(Ty::StDxCtx_crefPtr&lt;T&gt; pustDxCtx) {
		return detail_::z_make_unique&lt;T&gt;( pustDxCtx );
	}</span>
};

// the full specialization Dx12
template&lt;&gt; struct FactoryAdjustAux&lt;DxVer::v12&gt;  { 
	static
	auto create(
		Ty::StDxCtx_crefPtr&lt;DxVer::v12&gt; pustDxCtx
		, Dx::Spec::D12::Waiter *psoWaiter
		, Dx::Spec::D12::SetterRootSignature::cref_t setterRootSignature
<span style = "background-color:#fdd">	) {
		return detail_::z_make_unique&lt;DxVer::v12&gt;( pustDxCtx, psoWaiter, setterRootSignature );
	}</span>
};

} // namespace prj_3d::HelloWinHlsl::Dx</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>