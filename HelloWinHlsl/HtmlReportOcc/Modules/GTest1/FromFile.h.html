<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>FromFile.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿// Dx/Tool/Shader/Loader/ByteCode/FromFile.h - loader shader from shader source code placed in memory
#pragma once
namespace prj_3d::HelloWinHlsl::Dx::Tool::Shader::Loader::ByteCode {
// common reader
namespace detail_ { 
static std::vector&lt;char&gt; read(const std::wstring &amp;strRelFileName) {
	const std::wstring strFullFileName = Shader::Locator::locate( strRelFileName );
	std::ifstream file( strFullFileName, std::ios::binary );
	return std::vector&lt;char&gt;( std::istreambuf_iterator&lt;char&gt;( file ), {} );
}
} // namespace detail_

template&lt;class TSPE,class T&gt; class FromFile; // primary template

template&lt;class T&gt; class FromFile&lt;DxVer::v9,T&gt; {
	using TInnerDxVer = DxVer::v9;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit FromFile(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>
	// Load the vertex shader bytecode.
	CPtr&lt;IDirect3DVertexShader9&gt; Vs(const std::wstring&amp; strRelFileName, std::vector&lt;char&gt;* pveShaderByte = nullptr) {
		auto veMem = detail_::read( strRelFileName );
		if ( !veMem.size( ) )
			return { };
		CPtr&lt;IDirect3DVertexShader9&gt; pcVS;
		// If you compile the shader in fxc.exe with "vs_2_0" (as in the examples for Dx9), then it is not accepted in CreateVertexShader().
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateVertexShader( 
				reinterpret_cast&lt;DWORD *&gt;( veMem.data( ) )
				, pcVS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		if ( pveShaderByte )
			*pveShaderByte = veMem;
		return pcVS;
	}
	// Load the pixel shader bytecode.
	CPtr&lt;IDirect3DPixelShader9&gt; Ps(const std::wstring&amp; strRelFileName) {
		auto veMem = detail_::read( strRelFileName );
		if ( !veMem.size( ) )
			return { };
		CPtr&lt;IDirect3DPixelShader9&gt; pcPS;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreatePixelShader( 
				reinterpret_cast&lt;DWORD *&gt;( veMem.data( ) )
				, pcPS.ReleaseAndGetAddressOf( ) 
			);
		if ( FAILED( hr ) )
			return { };
		return pcPS;
	}

};

template&lt;class T&gt; class FromFile&lt;DxVer::v10,T&gt; {
	using TInnerDxVer = DxVer::v10;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit FromFile(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	// Load effect bytecode.
	CPtr&lt;ID3D10Effect&gt; Fx(const std::wstring&amp; strRelFileName) {
		auto veMem = detail_::read( strRelFileName );
		if ( !veMem.size( ) )
			return { };
		// Read the D3DX effect file
		DWORD dwShaderFlags = D3D10_SHADER_ENABLE_STRICTNESS
#ifdef _DEBUG
				// Set the D3D10_SHADER_DEBUG flag to embed debug information in the shaders.
				// Setting this flag improves the shader debugging experience, but still allows 
				// the shaders to be optimized and to run exactly the way they will run in 
				// the release configuration of this program.
				| D3D10_SHADER_DEBUG
				// Otherwise, there will be a warning in VsGa: "This draw call uses system-value semantics that interfere with pixel history computation"
				| D3D10_SHADER_SKIP_OPTIMIZATION
#endif // _DEBUG
			;
		CPtr&lt;ID3D10Blob&gt; pcD3dBlobErrorMsg = nullptr;
		CPtr&lt;ID3D10Effect&gt; pcEffect10 = nullptr;
		::D3DX10CreateEffectFromMemory( veMem.data( ), veMem.size( ), NULL,  NULL, NULL
				, "fx_4_0", dwShaderFlags, 0, m_stDxCtx -&gt;m_pcD3dDevice.Get( ), NULL
				, NULL, pcEffect10.ReleaseAndGetAddressOf( ), pcD3dBlobErrorMsg.ReleaseAndGetAddressOf( ), NULL 
			);
		if ( pcD3dBlobErrorMsg ) {
			// TODO: Use a trace class that can change the functionality.
			::OutputDebugStringA( static_cast&lt;char *&gt;( pcD3dBlobErrorMsg -&gt;GetBufferPointer( ) ) );
		}
		return pcEffect10;
	}

	// Load the vertex shader bytecode.
	CPtr&lt;ID3D10VertexShader&gt; Vs(const std::wstring&amp; strRelFileName, std::vector&lt;char&gt;* pveShaderByte = nullptr) {
		auto veMem = detail_::read( strRelFileName );
		if ( !veMem.size( ) )
			return { };
		CPtr&lt;ID3D10VertexShader&gt; pcVS;
		// If you compile the shader in fxc.exe with "vs_2_0" (as in the examples for Dx9), then it is not accepted in CreateVertexShader().
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateVertexShader( veMem.data( ), veMem.size( ), pcVS.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return { };
		if ( pveShaderByte )
			*pveShaderByte = veMem;
		return pcVS;
	}

	// Load the pixel shader bytecode.
	CPtr&lt;ID3D10PixelShader&gt; Ps(const std::wstring&amp; strRelFileName) {
		auto veMem = detail_::read( strRelFileName );
		if ( !veMem.size( ) )
			return { };
		CPtr&lt;ID3D10PixelShader&gt; pcPS;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreatePixelShader( veMem.data( ), veMem.size( ), pcPS.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return { };
		return pcPS;
	}
};

template&lt;class T&gt; class FromFile&lt;DxVer::v11,T&gt; {
	using TInnerDxVer = DxVer::v11;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit FromFile(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	// Load the vertex shader bytecode.
	CPtr&lt; ID3D11VertexShader &gt; Vs(const std::wstring&amp; strRelFileName, std::vector&lt;char&gt;* pveShaderByte = nullptr) {
		auto veMem = detail_::read( strRelFileName );
		if ( !veMem.size( ) )
			return { };
		CPtr&lt; ID3D11VertexShader &gt; pcVS;
		// If you compile the shader in fxc.exe with "vs_2_0" (as in the examples for Dx9), then it is not accepted in CreateVertexShader().
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreateVertexShader( veMem.data( ), veMem.size( ), nullptr, pcVS.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return { };
		if ( pveShaderByte )
			*pveShaderByte = veMem;
		return pcVS;
	}

	// Load the pixel shader bytecode.
	CPtr&lt; ID3D11PixelShader &gt; Ps(const std::wstring&amp; strRelFileName) {
		auto veMem = detail_::read( strRelFileName );
		if ( !veMem.size( ) )
			return { };
		CPtr&lt; ID3D11PixelShader &gt; pcPS;
		HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreatePixelShader( veMem.data( ), veMem.size( ), nullptr, pcPS.ReleaseAndGetAddressOf( ) );
		//ID3D11PixelShader **ifcPS = pcPS.ReleaseAndGetAddressOf( );
		//HRESULT hr = m_stDxCtx -&gt;m_pcD3dDevice -&gt;CreatePixelShader( veMem.data( ), veMem.size( ), nullptr, ifcPS );
		if ( FAILED( hr ) )
			return { };
		return pcPS;
	}
};

template&lt;class T&gt; class FromFile&lt;DxVer::v12,T&gt; {
	using TInnerDxVer = DxVer::v12;
	const Ty::StDxCtx_ptr&lt;TInnerDxVer&gt; m_stDxCtx;
public:
	explicit FromFile(Ty::StDxCtx_crefPtr&lt;TInnerDxVer&gt; stDxCtx) 
<span style = "background-color:#fdd">		: m_stDxCtx( stDxCtx )
	{}</span>

	// Load the vertex shader bytecode.
	CPtr&lt; ID3DBlob &gt; Vs(const std::wstring&amp; strRelFileName) {
		CPtr&lt; ID3DBlob &gt; pcVS;
		const std::wstring strFullFileName = Shader::Locator::locate( strRelFileName );
		HRESULT hr = ::D3DReadFileToBlob( 
			strFullFileName.c_str( ), pcVS.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return { };
		return pcVS;
	}

	// Load the pixel shader bytecode.
	CPtr&lt; ID3DBlob &gt; Ps(const std::wstring&amp; strRelFileName) {
		CPtr&lt; ID3DBlob &gt; pcPS;
		const std::wstring strFullFileName = Shader::Locator::locate( strRelFileName );
		HRESULT hr = ::D3DReadFileToBlob( 
			strFullFileName.c_str( ), pcPS.ReleaseAndGetAddressOf( ) );
		if ( FAILED( hr ) )
			return { };
		return pcPS;
	}
};
} // namespace prj_3d::HelloWinHlsl::Dx::Tool::Shader::Loader::ByteCode</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>