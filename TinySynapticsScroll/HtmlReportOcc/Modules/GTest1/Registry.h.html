<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Registry.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// src\Tool\Registry.h - minor registry operations
#pragma once // Copyright 2023 Alex0vSky (https://github.com/Alex0vSky)
namespace prj_sysw { namespace TinySynapticsScroll { namespace Tool { 
class Registry {
	const HKEY m_hRootKey;
	HKEY m_hSubKey;
	const REGSAM m_samDesired;
	Registry(HKEY hRootKey, HKEY hSubKey, REGSAM samDesired) 
<span style = "background-color:#dfd">		: m_hRootKey( hRootKey ), m_hSubKey( hSubKey ), m_samDesired( samDesired )
    {}</span>
	
 public:
	static const size_t s_hInitialSubKey = MAXSIZE_T;
<span style = "background-color:#dfd">	~Registry() {
		::RegCloseKey( m_hRootKey );
		if ( reinterpret_cast&lt; HKEY &gt;( s_hInitialSubKey ) != m_hSubKey )
			::RegCloseKey( m_hSubKey );
	}</span>
	enum class EnuRootKey {
		// HKEY_CURRENT_USER
		HKCU, 
		// HKEY_LOCAL_MACHINE
		HKLM, 
	};
	enum class EnuDesiredAccessRights {
		// KEY_ALL_ACCESS 
		ALL_ACCESS, 
		// KEY_READ 
		READ, 
	};

<span style = "background-color:#dfd">	bool readString(const wchar_t *wcsValueName, Tool::HeapMem *poBuf, size_t *psiLen = nullptr) const { 
		DWORD cbData = (DWORD)poBuf -&gt;getSize( );
		LSTATUS lst = ::RegGetValueW( </span>
			m_hSubKey, nullptr, wcsValueName, RRF_RT_REG_SZ, nullptr, poBuf -&gt;getMemPtr( ), &amp;cbData );
<span style = "background-color:#dfd">		if ( ERROR_SUCCESS != lst )
			return false;
		if ( psiLen )
			*psiLen = ( ( cbData / sizeof( wcsValueName[ 0 ] ) ) - 1 );
		return true;
	}
	bool readDword(const wchar_t *wcsValueName, DWORD *pdwReadValue) const { 
		DWORD dwType = REG_DWORD, cbData = sizeof( DWORD );
		return ERROR_SUCCESS == ::RegQueryValueExW( </span>
			m_hSubKey, wcsValueName, nullptr, &amp;dwType, reinterpret_cast&lt;LPBYTE&gt;( pdwReadValue ), &amp;cbData );
<span style = "background-color:#dfd">	}
	bool createAndSetValueDword(const wchar_t *wcsValueName, DWORD dwValue) const { 
		return ERROR_SUCCESS == ::RegSetValueExW( </span>
			m_hSubKey, wcsValueName, 0, REG_DWORD, (LPBYTE)&amp;dwValue, sizeof( DWORD ) );
<span style = "background-color:#dfd">	}
	bool createAndSetValueString(const wchar_t *wcsValueName, const wchar_t *wcsValue) const { 
		size_t cchLength = 0; 
		const wchar_t *wcs = wcsValue; 
		while ( *(wcs++) ) {}
		--wcs; 
		cchLength = static_cast&lt;size_t&gt;( wcs - wcsValue ); // aka strlen
		LSTATUS lst = ::RegSetValueExW( </span>
			m_hSubKey, wcsValueName, 0, REG_SZ, reinterpret_cast&lt;const BYTE *&gt;( wcsValue )
			, DWORD( cchLength *sizeof( wchar_t ) ) );
<span style = "background-color:#dfd">		return ERROR_SUCCESS == lst;
	}
	bool deleteValue(const wchar_t *wcsValueName) const { 
		return ERROR_SUCCESS == ::RegDeleteValueW( m_hSubKey, wcsValueName );
	}</span>

	// RVO
	static Registry openAlways(
		EnuRootKey enuRootKey
		, const wchar_t *wcsSubKey
		, EnuDesiredAccessRights enuRights = EnuDesiredAccessRights::READ
<span style = "background-color:#dfd">	) {
		HKEY hRootKey = (HKEY)-1;
		if ( false ) {}
		else if ( EnuRootKey::HKCU == enuRootKey )
			hRootKey = HKEY_CURRENT_USER;
		else if ( EnuRootKey::HKLM == enuRootKey )
			hRootKey = HKEY_LOCAL_MACHINE;
		REGSAM samDesired = 0;
		if ( false ) {}
		else if ( EnuDesiredAccessRights::ALL_ACCESS == enuRights )
			samDesired = KEY_ALL_ACCESS;
		else if ( EnuDesiredAccessRights::READ == enuRights )
			samDesired = KEY_READ;
		HKEY hSubKey = reinterpret_cast&lt; HKEY &gt;( s_hInitialSubKey );
		DWORD ulOptions = REG_OPTION_NON_VOLATILE; // default
		if ( ERROR_SUCCESS != ::RegOpenKeyExW( hRootKey, wcsSubKey, ulOptions, samDesired, &amp;hSubKey ) )
			::RegCreateKeyExW( hRootKey, wcsSubKey, 0, nullptr, ulOptions, samDesired, nullptr, &amp;hSubKey, nullptr );
		return Registry( hRootKey, hSubKey, samDesired );
	}</span>
	Registry(const Registry&amp;&amp; rhs) 
		: m_hRootKey( std::move( rhs.m_hRootKey ) ) // NOLINT(build/include_what_you_use)
		, m_hSubKey( std::move( rhs.m_hSubKey ) ) // NOLINT(build/include_what_you_use)
		, m_samDesired( std::move( rhs.m_samDesired ) ) // NOLINT(build/include_what_you_use)
    {}
	Registry(const Registry&amp;) = delete;

	Registry &amp;operator = (const Registry &amp;) = delete;
};
}}} // namespace prj_sysw::TinySynapticsScroll::Tool _</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>